        -:    0:Source:/home/jonathan/Documents/mse/tm/FlightSoftware/FPrime/05_FS/App/build-fprime-automatic-native-ut/App/EventAction/EventActionComponentAc.cpp
        -:    0:Programs:3
        -:    1:// ======================================================================
        -:    2:// \title  EventActionComponentAc.cpp
        -:    3:// \author Auto-generated
        -:    4:// \brief  cpp file for EventAction component base class
        -:    5://
        -:    6:// \copyright
        -:    7:// Copyright 2009-2015, by the California Institute of Technology.
        -:    8:// ALL RIGHTS RESERVED.  United States Government Sponsorship
        -:    9:// acknowledged.
        -:   10://
        -:   11:// ======================================================================
        -:   12:
        -:   13:#include <stdio.h>
        -:   14:#include <FpConfig.hpp>
        -:   15:#include <App/EventAction/EventActionComponentAc.hpp>
        -:   16:#include <Fw/Types/Assert.hpp>
        -:   17:#if FW_ENABLE_TEXT_LOGGING
        -:   18:#include <Fw/Types/EightyCharString.hpp>
        -:   19:#endif
        -:   20:
        -:   21:
        -:   22:namespace App {
        -:   23:
        -:   24:  // ----------------------------------------------------------------------
        -:   25:  // Anonymous namespace to prevent name collisions
        -:   26:  // ----------------------------------------------------------------------
        -:   27:
        -:   28:  namespace {
        -:   29:
        -:   30:    typedef enum {
        -:   31:      EVENTACTION_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
        -:   32:      SEQRESP_CMDRESPONSE,
        -:   33:      LOGRECV_LOG,
        -:   34:      CMD_EVAC_ADD,
        -:   35:      CMD_EVAC_REMOVE,
        -:   36:      CMD_EVAC_DUMP
        -:   37:    } MsgTypeEnum;
        -:   38:
        -:   39:    // Get the max size by doing a union of the input port serialization sizes.
        -:   40:
        -:   41:    typedef union {
        -:   42:      BYTE port1[Fw::InputCmdResponsePort::SERIALIZED_SIZE];
        -:   43:      BYTE port2[Fw::InputLogPort::SERIALIZED_SIZE];
        -:   44:      BYTE cmdPort[Fw::InputCmdPort::SERIALIZED_SIZE];
        -:   45:    } BuffUnion;
        -:   46:
        -:   47:    // Define a message buffer class large enough to handle all the
        -:   48:    // asynchronous inputs to the component
        -:   49:
      228:   50:    class ComponentIpcSerializableBuffer :
        -:   51:      public Fw::SerializeBufferBase
        -:   52:    {
        -:   53:
        -:   54:      public:
        -:   55:
        -:   56:        enum {
        -:   57:          // Max. message size = size of data + message id + port
        -:   58:          SERIALIZATION_SIZE =
        -:   59:            sizeof(BuffUnion) +
        -:   60:            sizeof(NATIVE_INT_TYPE) +
        -:   61:            sizeof(NATIVE_INT_TYPE)
        -:   62:        };
        -:   63:
      480:   64:        NATIVE_UINT_TYPE getBuffCapacity(void) const {
      480:   65:          return sizeof(m_buff);
        -:   66:        }
        -:   67:
     3087:   68:        U8* getBuffAddr(void) {
     3087:   69:          return m_buff;
        -:   70:        }
        -:   71:
       57:   72:        const U8* getBuffAddr(void) const {
       57:   73:          return m_buff;
        -:   74:        }
        -:   75:
        -:   76:      private:
        -:   77:        // Should be the max of all the input ports serialized sizes...
        -:   78:        U8 m_buff[SERIALIZATION_SIZE];
        -:   79:
        -:   80:    };
        -:   81:
        -:   82:  }
        -:   83:
        -:   84:  // ----------------------------------------------------------------------
        -:   85:  // Getters for numbers of input ports
        -:   86:  // ----------------------------------------------------------------------
        -:   87:
       30:   88:  Fw::InputCmdPort *EventActionComponentBase ::
        -:   89:    get_cmdDisp_InputPort(NATIVE_INT_TYPE portNum)
        -:   90:  {
       30:   91:    FW_ASSERT(portNum < this->getNum_cmdDisp_InputPorts(),static_cast<AssertArg>(portNum));
       30:   92:    return &this->m_cmdDisp_InputPort[portNum];
        -:   93:  }
        -:   94:
       30:   95:  Fw::InputCmdResponsePort *EventActionComponentBase ::
        -:   96:    get_seqResp_InputPort(NATIVE_INT_TYPE portNum)
        -:   97:  {
       30:   98:    FW_ASSERT(portNum < this->getNum_seqResp_InputPorts(),static_cast<AssertArg>(portNum));
       30:   99:    return &this->m_seqResp_InputPort[portNum];
        -:  100:  }
        -:  101:
       30:  102:  Fw::InputLogPort *EventActionComponentBase ::
        -:  103:    get_logRecv_InputPort(NATIVE_INT_TYPE portNum)
        -:  104:  {
       30:  105:    FW_ASSERT(portNum < this->getNum_logRecv_InputPorts(),static_cast<AssertArg>(portNum));
       30:  106:    return &this->m_logRecv_InputPort[portNum];
        -:  107:  }
        -:  108:
        -:  109:  // ----------------------------------------------------------------------
        -:  110:  // Typed connectors for output ports
        -:  111:  // ----------------------------------------------------------------------
        -:  112:
       30:  113:  void EventActionComponentBase ::
        -:  114:    set_cmdRegOut_OutputPort(
        -:  115:        NATIVE_INT_TYPE portNum,
        -:  116:        Fw::InputCmdRegPort* port
        -:  117:    )
        -:  118:  {
       30:  119:    FW_ASSERT(portNum < this->getNum_cmdRegOut_OutputPorts(),static_cast<AssertArg>(portNum));
       30:  120:    this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
       30:  121:  }
        -:  122:
       30:  123:  void EventActionComponentBase ::
        -:  124:    set_cmdResponseOut_OutputPort(
        -:  125:        NATIVE_INT_TYPE portNum,
        -:  126:        Fw::InputCmdResponsePort* port
        -:  127:    )
        -:  128:  {
       30:  129:    FW_ASSERT(portNum < this->getNum_cmdResponseOut_OutputPorts(),static_cast<AssertArg>(portNum));
       30:  130:    this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
       30:  131:  }
        -:  132:
       30:  133:  void EventActionComponentBase ::
        -:  134:    set_eventOut_OutputPort(
        -:  135:        NATIVE_INT_TYPE portNum,
        -:  136:        Fw::InputLogPort* port
        -:  137:    )
        -:  138:  {
       30:  139:    FW_ASSERT(portNum < this->getNum_eventOut_OutputPorts(),static_cast<AssertArg>(portNum));
       30:  140:    this->m_eventOut_OutputPort[portNum].addCallPort(port);
       30:  141:  }
        -:  142:
        -:  143:#if FW_ENABLE_TEXT_LOGGING == 1
       30:  144:  void EventActionComponentBase ::
        -:  145:    set_txtEventOut_OutputPort(
        -:  146:        NATIVE_INT_TYPE portNum,
        -:  147:        Fw::InputLogTextPort* port
        -:  148:    )
        -:  149:  {
       30:  150:    FW_ASSERT(portNum < this->getNum_txtEventOut_OutputPorts(),static_cast<AssertArg>(portNum));
       30:  151:    this->m_txtEventOut_OutputPort[portNum].addCallPort(port);
       30:  152:  }
        -:  153:#endif
        -:  154:
       30:  155:  void EventActionComponentBase ::
        -:  156:    set_seqRun_OutputPort(
        -:  157:        NATIVE_INT_TYPE portNum,
        -:  158:        Svc::InputCmdSeqInPort* port
        -:  159:    )
        -:  160:  {
       30:  161:    FW_ASSERT(portNum < this->getNum_seqRun_OutputPorts(),static_cast<AssertArg>(portNum));
       30:  162:    this->m_seqRun_OutputPort[portNum].addCallPort(port);
       30:  163:  }
        -:  164:
       30:  165:  void EventActionComponentBase ::
        -:  166:    set_Time_OutputPort(
        -:  167:        NATIVE_INT_TYPE portNum,
        -:  168:        Fw::InputTimePort* port
        -:  169:    )
        -:  170:  {
       30:  171:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
       30:  172:    this->m_Time_OutputPort[portNum].addCallPort(port);
       30:  173:  }
        -:  174:
        -:  175:  // ----------------------------------------------------------------------
        -:  176:  // Serialization connectors for output ports
        -:  177:  // ----------------------------------------------------------------------
        -:  178:
        -:  179:#if FW_PORT_SERIALIZATION
        -:  180:
    #####:  181:  void EventActionComponentBase ::
        -:  182:    set_cmdRegOut_OutputPort(
        -:  183:        NATIVE_INT_TYPE portNum,
        -:  184:        Fw::InputSerializePort *port
        -:  185:    )
        -:  186:  {
    #####:  187:    FW_ASSERT(portNum < this->getNum_cmdRegOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  188:    return this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
        -:  189:  }
        -:  190:
    #####:  191:  void EventActionComponentBase ::
        -:  192:    set_cmdResponseOut_OutputPort(
        -:  193:        NATIVE_INT_TYPE portNum,
        -:  194:        Fw::InputSerializePort *port
        -:  195:    )
        -:  196:  {
    #####:  197:    FW_ASSERT(portNum < this->getNum_cmdResponseOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  198:    return this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
        -:  199:  }
        -:  200:
    #####:  201:  void EventActionComponentBase ::
        -:  202:    set_eventOut_OutputPort(
        -:  203:        NATIVE_INT_TYPE portNum,
        -:  204:        Fw::InputSerializePort *port
        -:  205:    )
        -:  206:  {
    #####:  207:    FW_ASSERT(portNum < this->getNum_eventOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  208:    return this->m_eventOut_OutputPort[portNum].registerSerialPort(port);
        -:  209:  }
        -:  210:
        -:  211:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  212:  void EventActionComponentBase ::
        -:  213:    set_txtEventOut_OutputPort(
        -:  214:        NATIVE_INT_TYPE portNum,
        -:  215:        Fw::InputSerializePort *port
        -:  216:    )
        -:  217:  {
    #####:  218:    FW_ASSERT(portNum < this->getNum_txtEventOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  219:    return this->m_txtEventOut_OutputPort[portNum].registerSerialPort(port);
        -:  220:  }
        -:  221:#endif
        -:  222:
    #####:  223:  void EventActionComponentBase ::
        -:  224:    set_seqRun_OutputPort(
        -:  225:        NATIVE_INT_TYPE portNum,
        -:  226:        Fw::InputSerializePort *port
        -:  227:    )
        -:  228:  {
    #####:  229:    FW_ASSERT(portNum < this->getNum_seqRun_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  230:    return this->m_seqRun_OutputPort[portNum].registerSerialPort(port);
        -:  231:  }
        -:  232:
    #####:  233:  void EventActionComponentBase ::
        -:  234:    set_Time_OutputPort(
        -:  235:        NATIVE_INT_TYPE portNum,
        -:  236:        Fw::InputSerializePort *port
        -:  237:    )
        -:  238:  {
    #####:  239:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  240:    return this->m_Time_OutputPort[portNum].registerSerialPort(port);
        -:  241:  }
        -:  242:
        -:  243:#endif
        -:  244:
        -:  245:  // ----------------------------------------------------------------------
        -:  246:  // Command registration
        -:  247:  // ----------------------------------------------------------------------
        -:  248:
    #####:  249:  void EventActionComponentBase ::
        -:  250:    regCommands(void)
        -:  251:  {
    #####:  252:    FW_ASSERT(this->m_cmdRegOut_OutputPort[0].isConnected());
    #####:  253:    this->m_cmdRegOut_OutputPort[0].invoke(
        -:  254:        this->getIdBase() + OPCODE_EVAC_ADD
        -:  255:    );
    #####:  256:    this->m_cmdRegOut_OutputPort[0].invoke(
    #####:  257:        this->getIdBase() + OPCODE_EVAC_REMOVE
        -:  258:    );
    #####:  259:    this->m_cmdRegOut_OutputPort[0].invoke(
    #####:  260:        this->getIdBase() + OPCODE_EVAC_DUMP
        -:  261:    );
    #####:  262:  }
        -:  263:
        -:  264:  // ----------------------------------------------------------------------
        -:  265:  // Component construction, initialization, and destruction
        -:  266:  // ----------------------------------------------------------------------
        -:  267:
       30:  268:    EventActionComponentBase :: EventActionComponentBase(const char* compName) :
       30:  269:        Fw::ActiveComponentBase(compName) {
        -:  270:
        -:  271:
        -:  272:
       30:  273:  }
        -:  274:
       30:  275:  void EventActionComponentBase ::
        -:  276:    init(
        -:  277:        NATIVE_INT_TYPE queueDepth,
        -:  278:        NATIVE_INT_TYPE instance
        -:  279:    )
        -:  280:  {
        -:  281:
        -:  282:    // Initialize base class
       30:  283:    Fw::ActiveComponentBase::init(instance);
        -:  284:
        -:  285:    // Connect input port cmdDisp
       30:  286:    for (
       30:  287:        NATIVE_INT_TYPE port = 0;
       60:  288:        port < this->getNum_cmdDisp_InputPorts();
        -:  289:        port++
        -:  290:    ) {
        -:  291:
       30:  292:      this->m_cmdDisp_InputPort[port].init();
       30:  293:      this->m_cmdDisp_InputPort[port].addCallComp(
        -:  294:          this,
        -:  295:          m_p_cmdDisp_in
        -:  296:      );
       30:  297:      this->m_cmdDisp_InputPort[port].setPortNum(port);
        -:  298:
        -:  299:#if FW_OBJECT_NAMES == 1
        -:  300:      char portName[120];
       30:  301:      (void) snprintf(
        -:  302:          portName,
        -:  303:          sizeof(portName),
        -:  304:          "%s_cmdDisp_InputPort[%d]",
        -:  305:          this->m_objName,
        -:  306:          port
        -:  307:      );
       30:  308:      this->m_cmdDisp_InputPort[port].setObjName(portName);
        -:  309:#endif
        -:  310:
        -:  311:    }
        -:  312:
        -:  313:    // Connect input port seqResp
       30:  314:    for (
       30:  315:        NATIVE_INT_TYPE port = 0;
       60:  316:        port < this->getNum_seqResp_InputPorts();
        -:  317:        port++
        -:  318:    ) {
        -:  319:
       30:  320:      this->m_seqResp_InputPort[port].init();
       30:  321:      this->m_seqResp_InputPort[port].addCallComp(
        -:  322:          this,
        -:  323:          m_p_seqResp_in
        -:  324:      );
       30:  325:      this->m_seqResp_InputPort[port].setPortNum(port);
        -:  326:
        -:  327:#if FW_OBJECT_NAMES == 1
        -:  328:      char portName[120];
       30:  329:      (void) snprintf(
        -:  330:          portName,
        -:  331:          sizeof(portName),
        -:  332:          "%s_seqResp_InputPort[%d]",
        -:  333:          this->m_objName,
        -:  334:          port
        -:  335:      );
       30:  336:      this->m_seqResp_InputPort[port].setObjName(portName);
        -:  337:#endif
        -:  338:
        -:  339:    }
        -:  340:
        -:  341:    // Connect input port logRecv
       30:  342:    for (
       30:  343:        NATIVE_INT_TYPE port = 0;
       60:  344:        port < this->getNum_logRecv_InputPorts();
        -:  345:        port++
        -:  346:    ) {
        -:  347:
       30:  348:      this->m_logRecv_InputPort[port].init();
       30:  349:      this->m_logRecv_InputPort[port].addCallComp(
        -:  350:          this,
        -:  351:          m_p_logRecv_in
        -:  352:      );
       30:  353:      this->m_logRecv_InputPort[port].setPortNum(port);
        -:  354:
        -:  355:#if FW_OBJECT_NAMES == 1
        -:  356:      char portName[120];
       30:  357:      (void) snprintf(
        -:  358:          portName,
        -:  359:          sizeof(portName),
        -:  360:          "%s_logRecv_InputPort[%d]",
        -:  361:          this->m_objName,
        -:  362:          port
        -:  363:      );
       30:  364:      this->m_logRecv_InputPort[port].setObjName(portName);
        -:  365:#endif
        -:  366:
        -:  367:    }
        -:  368:
        -:  369:    // Initialize output port cmdRegOut
       30:  370:    for (
       30:  371:        NATIVE_INT_TYPE port = 0;
       60:  372:        port < this->getNum_cmdRegOut_OutputPorts();
        -:  373:        port++
        -:  374:    ) {
       30:  375:      this->m_cmdRegOut_OutputPort[port].init();
        -:  376:
        -:  377:#if FW_OBJECT_NAMES == 1
        -:  378:      char portName[120];
       30:  379:      (void) snprintf(
        -:  380:          portName,
        -:  381:          sizeof(portName),
        -:  382:          "%s_cmdRegOut_OutputPort[%d]",
        -:  383:          this->m_objName,
        -:  384:          port
        -:  385:      );
       30:  386:      this->m_cmdRegOut_OutputPort[port].setObjName(portName);
        -:  387:#endif
        -:  388:
        -:  389:    }
        -:  390:
        -:  391:    // Initialize output port cmdResponseOut
       30:  392:    for (
       30:  393:        NATIVE_INT_TYPE port = 0;
       60:  394:        port < this->getNum_cmdResponseOut_OutputPorts();
        -:  395:        port++
        -:  396:    ) {
       30:  397:      this->m_cmdResponseOut_OutputPort[port].init();
        -:  398:
        -:  399:#if FW_OBJECT_NAMES == 1
        -:  400:      char portName[120];
       30:  401:      (void) snprintf(
        -:  402:          portName,
        -:  403:          sizeof(portName),
        -:  404:          "%s_cmdResponseOut_OutputPort[%d]",
        -:  405:          this->m_objName,
        -:  406:          port
        -:  407:      );
       30:  408:      this->m_cmdResponseOut_OutputPort[port].setObjName(portName);
        -:  409:#endif
        -:  410:
        -:  411:    }
        -:  412:
        -:  413:    // Initialize output port eventOut
       30:  414:    for (
       30:  415:        NATIVE_INT_TYPE port = 0;
       60:  416:        port < this->getNum_eventOut_OutputPorts();
        -:  417:        port++
        -:  418:    ) {
       30:  419:      this->m_eventOut_OutputPort[port].init();
        -:  420:
        -:  421:#if FW_OBJECT_NAMES == 1
        -:  422:      char portName[120];
       30:  423:      (void) snprintf(
        -:  424:          portName,
        -:  425:          sizeof(portName),
        -:  426:          "%s_eventOut_OutputPort[%d]",
        -:  427:          this->m_objName,
        -:  428:          port
        -:  429:      );
       30:  430:      this->m_eventOut_OutputPort[port].setObjName(portName);
        -:  431:#endif
        -:  432:
        -:  433:    }
        -:  434:
        -:  435:    // Initialize output port txtEventOut
        -:  436:#if FW_ENABLE_TEXT_LOGGING == 1
       30:  437:    for (
       30:  438:        NATIVE_INT_TYPE port = 0;
       60:  439:        port < this->getNum_txtEventOut_OutputPorts();
        -:  440:        port++
        -:  441:    ) {
       30:  442:      this->m_txtEventOut_OutputPort[port].init();
        -:  443:
        -:  444:#if FW_OBJECT_NAMES == 1
        -:  445:      char portName[120];
       30:  446:      (void) snprintf(
        -:  447:          portName,
        -:  448:          sizeof(portName),
        -:  449:          "%s_txtEventOut_OutputPort[%d]",
        -:  450:          this->m_objName,
        -:  451:          port
        -:  452:      );
       30:  453:      this->m_txtEventOut_OutputPort[port].setObjName(portName);
        -:  454:#endif
        -:  455:
        -:  456:    }
        -:  457:#endif
        -:  458:
        -:  459:    // Initialize output port seqRun
       30:  460:    for (
       30:  461:        NATIVE_INT_TYPE port = 0;
       60:  462:        port < this->getNum_seqRun_OutputPorts();
        -:  463:        port++
        -:  464:    ) {
       30:  465:      this->m_seqRun_OutputPort[port].init();
        -:  466:
        -:  467:#if FW_OBJECT_NAMES == 1
        -:  468:      char portName[120];
       30:  469:      (void) snprintf(
        -:  470:          portName,
        -:  471:          sizeof(portName),
        -:  472:          "%s_seqRun_OutputPort[%d]",
        -:  473:          this->m_objName,
        -:  474:          port
        -:  475:      );
       30:  476:      this->m_seqRun_OutputPort[port].setObjName(portName);
        -:  477:#endif
        -:  478:
        -:  479:    }
        -:  480:
        -:  481:    // Initialize output port Time
       30:  482:    for (
       30:  483:        NATIVE_INT_TYPE port = 0;
       60:  484:        port < this->getNum_Time_OutputPorts();
        -:  485:        port++
        -:  486:    ) {
       30:  487:      this->m_Time_OutputPort[port].init();
        -:  488:
        -:  489:#if FW_OBJECT_NAMES == 1
        -:  490:      char portName[120];
       30:  491:      (void) snprintf(
        -:  492:          portName,
        -:  493:          sizeof(portName),
        -:  494:          "%s_Time_OutputPort[%d]",
        -:  495:          this->m_objName,
        -:  496:          port
        -:  497:      );
       30:  498:      this->m_Time_OutputPort[port].setObjName(portName);
        -:  499:#endif
        -:  500:
        -:  501:    }
        -:  502:
        -:  503:    Os::Queue::QueueStatus qStat =
       30:  504:    this->createQueue(
        -:  505:        queueDepth,
        -:  506:        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
       30:  507:    );
       30:  508:    FW_ASSERT(
        -:  509:        Os::Queue::QUEUE_OK == qStat,
        -:  510:        static_cast<AssertArg>(qStat)
        -:  511:    );
        -:  512:
       30:  513:  }
        -:  514:
       30:  515:  EventActionComponentBase::
       30:  516:    ~EventActionComponentBase() {
        -:  517:
       30:  518:  }
        -:  519:
        -:  520:  // ----------------------------------------------------------------------
        -:  521:  // Invocation functions for output ports
        -:  522:  // ----------------------------------------------------------------------
        -:  523:
        3:  524:  void EventActionComponentBase ::
        -:  525:    seqRun_out(
        -:  526:        NATIVE_INT_TYPE portNum,
        -:  527:        Fw::EightyCharString &filename
        -:  528:    )
        -:  529:  {
        3:  530:    FW_ASSERT(portNum < this->getNum_seqRun_OutputPorts(),static_cast<AssertArg>(portNum));
        3:  531:    this->m_seqRun_OutputPort[portNum].invoke(filename);
        3:  532:  }
        -:  533:
        -:  534:  // ----------------------------------------------------------------------
        -:  535:  // Getters for numbers of ports
        -:  536:  // ----------------------------------------------------------------------
        -:  537:
       90:  538:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  539:    getNum_cmdDisp_InputPorts(void)
        -:  540:  {
       90:  541:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  542:        this->m_cmdDisp_InputPort
        -:  543:    );
        -:  544:  }
        -:  545:
       90:  546:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  547:    getNum_cmdRegOut_OutputPorts(void)
        -:  548:  {
       90:  549:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  550:        this->m_cmdRegOut_OutputPort
        -:  551:    );
        -:  552:  }
        -:  553:
       90:  554:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  555:    getNum_cmdResponseOut_OutputPorts(void)
        -:  556:  {
       90:  557:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  558:        this->m_cmdResponseOut_OutputPort
        -:  559:    );
        -:  560:  }
        -:  561:
       90:  562:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  563:    getNum_eventOut_OutputPorts(void)
        -:  564:  {
       90:  565:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  566:        this->m_eventOut_OutputPort
        -:  567:    );
        -:  568:  }
        -:  569:
        -:  570:#if FW_ENABLE_TEXT_LOGGING == 1
       90:  571:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  572:    getNum_txtEventOut_OutputPorts(void)
        -:  573:  {
       90:  574:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  575:        this->m_txtEventOut_OutputPort
        -:  576:    );
        -:  577:  }
        -:  578:#endif
        -:  579:
       93:  580:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  581:    getNum_seqRun_OutputPorts(void)
        -:  582:  {
       93:  583:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  584:        this->m_seqRun_OutputPort
        -:  585:    );
        -:  586:  }
        -:  587:
       90:  588:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  589:    getNum_seqResp_InputPorts(void)
        -:  590:  {
       90:  591:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  592:        this->m_seqResp_InputPort
        -:  593:    );
        -:  594:  }
        -:  595:
       96:  596:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  597:    getNum_logRecv_InputPorts(void)
        -:  598:  {
       96:  599:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  600:        this->m_logRecv_InputPort
        -:  601:    );
        -:  602:  }
        -:  603:
       90:  604:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  605:    getNum_Time_OutputPorts(void)
        -:  606:  {
       90:  607:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  608:        this->m_Time_OutputPort
        -:  609:    );
        -:  610:  }
        -:  611:
        -:  612:  // ----------------------------------------------------------------------
        -:  613:  // Port connection status queries
        -:  614:  // ----------------------------------------------------------------------
        -:  615:
    #####:  616:  bool EventActionComponentBase ::
        -:  617:    isConnected_cmdRegOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  618:  {
    #####:  619:     FW_ASSERT(
        -:  620:        portNum < this->getNum_cmdRegOut_OutputPorts(),
        -:  621:        static_cast<AssertArg>(portNum)
        -:  622:     );
    #####:  623:     return this->m_cmdRegOut_OutputPort[portNum].isConnected();
        -:  624:  }
        -:  625:
    #####:  626:  bool EventActionComponentBase ::
        -:  627:    isConnected_cmdResponseOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  628:  {
    #####:  629:     FW_ASSERT(
        -:  630:        portNum < this->getNum_cmdResponseOut_OutputPorts(),
        -:  631:        static_cast<AssertArg>(portNum)
        -:  632:     );
    #####:  633:     return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
        -:  634:  }
        -:  635:
    #####:  636:  bool EventActionComponentBase ::
        -:  637:    isConnected_eventOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  638:  {
    #####:  639:     FW_ASSERT(
        -:  640:        portNum < this->getNum_eventOut_OutputPorts(),
        -:  641:        static_cast<AssertArg>(portNum)
        -:  642:     );
    #####:  643:     return this->m_eventOut_OutputPort[portNum].isConnected();
        -:  644:  }
        -:  645:
        -:  646:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  647:  bool EventActionComponentBase ::
        -:  648:    isConnected_txtEventOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  649:  {
    #####:  650:     FW_ASSERT(
        -:  651:        portNum < this->getNum_txtEventOut_OutputPorts(),
        -:  652:        static_cast<AssertArg>(portNum)
        -:  653:     );
    #####:  654:     return this->m_txtEventOut_OutputPort[portNum].isConnected();
        -:  655:  }
        -:  656:#endif
        -:  657:
    #####:  658:  bool EventActionComponentBase ::
        -:  659:    isConnected_seqRun_OutputPort(NATIVE_INT_TYPE portNum)
        -:  660:  {
    #####:  661:     FW_ASSERT(
        -:  662:        portNum < this->getNum_seqRun_OutputPorts(),
        -:  663:        static_cast<AssertArg>(portNum)
        -:  664:     );
    #####:  665:     return this->m_seqRun_OutputPort[portNum].isConnected();
        -:  666:  }
        -:  667:
    #####:  668:  bool EventActionComponentBase ::
        -:  669:    isConnected_Time_OutputPort(NATIVE_INT_TYPE portNum)
        -:  670:  {
    #####:  671:     FW_ASSERT(
        -:  672:        portNum < this->getNum_Time_OutputPorts(),
        -:  673:        static_cast<AssertArg>(portNum)
        -:  674:     );
    #####:  675:     return this->m_Time_OutputPort[portNum].isConnected();
        -:  676:  }
        -:  677:
        -:  678:  // ----------------------------------------------------------------------
        -:  679:  // Calls for messages received on command input ports
        -:  680:  // ----------------------------------------------------------------------
        -:  681:
       51:  682:  void EventActionComponentBase ::
        -:  683:    m_p_cmdDisp_in(
        -:  684:        Fw::PassiveComponentBase* callComp,
        -:  685:        NATIVE_INT_TYPE portNum,
        -:  686:        FwOpcodeType opCode,
        -:  687:        U32 cmdSeq,
        -:  688:        Fw::CmdArgBuffer &args
        -:  689:    )
        -:  690:  {
        -:  691:
        -:  692:    // Select base class function based on opcode
       51:  693:    FW_ASSERT(callComp);
       51:  694:    EventActionComponentBase* compPtr =
        -:  695:      (EventActionComponentBase*) callComp;
        -:  696:
       51:  697:    const U32 idBase = callComp->getIdBase();
       51:  698:    FW_ASSERT(opCode >= idBase, opCode, idBase);
       51:  699:    switch (opCode - idBase) {
        -:  700:
       36:  701:      case OPCODE_EVAC_ADD: /*!< Add sequence for an event id */
       36:  702:        compPtr->EVAC_ADD_cmdHandlerBase(
        -:  703:            opCode,
        -:  704:            cmdSeq,
        -:  705:            args
        -:  706:        );
       36:  707:        break;
        -:  708:
        9:  709:      case OPCODE_EVAC_REMOVE: /*!< Remove sequence for a specific envent id */
        9:  710:        compPtr->EVAC_REMOVE_cmdHandlerBase(
        -:  711:            opCode,
        -:  712:            cmdSeq,
        -:  713:            args
        -:  714:        );
        9:  715:        break;
        -:  716:
        6:  717:      case OPCODE_EVAC_DUMP: /*!< Dump event-sequence list */
        6:  718:        compPtr->EVAC_DUMP_cmdHandlerBase(
        -:  719:            opCode,
        -:  720:            cmdSeq,
        -:  721:            args
        -:  722:        );
        6:  723:        break;
        -:  724:
    #####:  725:      default: {
    #####:  726:        compPtr->cmdResponse_out(
        -:  727:            opCode,cmdSeq,
        -:  728:            Fw::COMMAND_INVALID_OPCODE
        -:  729:        );
    #####:  730:        break;
        -:  731:      }
        -:  732:
        -:  733:    }
        -:  734:
       51:  735:  }
        -:  736:
       51:  737:  void EventActionComponentBase ::
        -:  738:    cmdResponse_out(
        -:  739:        FwOpcodeType opCode,
        -:  740:        U32 cmdSeq,
        -:  741:        Fw::CommandResponse response
        -:  742:    )
        -:  743:  {
       51:  744:    FW_ASSERT(this->m_cmdResponseOut_OutputPort[0].isConnected());
       51:  745:    this->m_cmdResponseOut_OutputPort[0].invoke(opCode,cmdSeq,response);
       51:  746:  }
        -:  747:
        -:  748:  // ----------------------------------------------------------------------
        -:  749:  // Base class command functions
        -:  750:  // ----------------------------------------------------------------------
        -:  751:
       36:  752:  void EventActionComponentBase ::
        -:  753:    EVAC_ADD_cmdHandlerBase(
        -:  754:        FwOpcodeType opCode,
        -:  755:        U32 cmdSeq,
        -:  756:        Fw::CmdArgBuffer &args
        -:  757:    )
        -:  758:  {
        -:  759:
        -:  760:    // Call pre-message hook
       36:  761:    this->EVAC_ADD_preMsgHook(opCode,cmdSeq);
        -:  762:
        -:  763:    // Defer deserializing arguments to the message dispatcher
        -:  764:    // to avoid deserializing and reserializing just for IPC
       72:  765:    ComponentIpcSerializableBuffer msg;
       36:  766:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  767:
        -:  768:    // Serialize for IPC
       36:  769:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_EVAC_ADD);
       36:  770:    FW_ASSERT (
        -:  771:        _status == Fw::FW_SERIALIZE_OK,
        -:  772:        static_cast<AssertArg>(_status)
        -:  773:        );
        -:  774:
        -:  775:    // Fake port number to make message dequeue work
       36:  776:    NATIVE_INT_TYPE port = 0;
       36:  777:    _status = msg.serialize(port);
       36:  778:    FW_ASSERT (
        -:  779:        _status == Fw::FW_SERIALIZE_OK,
        -:  780:        static_cast<AssertArg>(_status)
        -:  781:    );
        -:  782:
       36:  783:    _status = msg.serialize(opCode);
       36:  784:    FW_ASSERT (
        -:  785:        _status == Fw::FW_SERIALIZE_OK,
        -:  786:        static_cast<AssertArg>(_status)
        -:  787:    );
        -:  788:
       36:  789:    _status = msg.serialize(cmdSeq);
       36:  790:    FW_ASSERT (
        -:  791:        _status == Fw::FW_SERIALIZE_OK,
        -:  792:        static_cast<AssertArg>(_status)
        -:  793:    );
        -:  794:
       36:  795:    _status = msg.serialize(args);
       36:  796:    FW_ASSERT (
        -:  797:        _status == Fw::FW_SERIALIZE_OK,
        -:  798:        static_cast<AssertArg>(_status)
        -:  799:    );
        -:  800:
        -:  801:    // send message
       36:  802:    Os::Queue::QueueBlocking _block =
        -:  803:      Os::Queue::QUEUE_NONBLOCKING;
        -:  804:    Os::Queue::QueueStatus qStatus =
       36:  805:      this->m_queue.send(msg, 0,_block);
       36:  806:    FW_ASSERT(
        -:  807:        qStatus == Os::Queue::QUEUE_OK,
        -:  808:        static_cast<AssertArg>(qStatus)
        -:  809:    );
        -:  810:
       36:  811:  }
        -:  812:
       36:  813:  void EventActionComponentBase::
        -:  814:    EVAC_ADD_preMsgHook(
        -:  815:        FwOpcodeType opCode,
        -:  816:        U32 cmdSeq
        -:  817:    )
        -:  818:  {
        -:  819:    // Defaults to no-op; can be overridden
       36:  820:  }
        -:  821:
        9:  822:  void EventActionComponentBase ::
        -:  823:    EVAC_REMOVE_cmdHandlerBase(
        -:  824:        FwOpcodeType opCode,
        -:  825:        U32 cmdSeq,
        -:  826:        Fw::CmdArgBuffer &args
        -:  827:    )
        -:  828:  {
        -:  829:
        -:  830:    // Call pre-message hook
        9:  831:    this->EVAC_REMOVE_preMsgHook(opCode,cmdSeq);
        -:  832:
        -:  833:    // Defer deserializing arguments to the message dispatcher
        -:  834:    // to avoid deserializing and reserializing just for IPC
       18:  835:    ComponentIpcSerializableBuffer msg;
        9:  836:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  837:
        -:  838:    // Serialize for IPC
        9:  839:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_EVAC_REMOVE);
        9:  840:    FW_ASSERT (
        -:  841:        _status == Fw::FW_SERIALIZE_OK,
        -:  842:        static_cast<AssertArg>(_status)
        -:  843:        );
        -:  844:
        -:  845:    // Fake port number to make message dequeue work
        9:  846:    NATIVE_INT_TYPE port = 0;
        9:  847:    _status = msg.serialize(port);
        9:  848:    FW_ASSERT (
        -:  849:        _status == Fw::FW_SERIALIZE_OK,
        -:  850:        static_cast<AssertArg>(_status)
        -:  851:    );
        -:  852:
        9:  853:    _status = msg.serialize(opCode);
        9:  854:    FW_ASSERT (
        -:  855:        _status == Fw::FW_SERIALIZE_OK,
        -:  856:        static_cast<AssertArg>(_status)
        -:  857:    );
        -:  858:
        9:  859:    _status = msg.serialize(cmdSeq);
        9:  860:    FW_ASSERT (
        -:  861:        _status == Fw::FW_SERIALIZE_OK,
        -:  862:        static_cast<AssertArg>(_status)
        -:  863:    );
        -:  864:
        9:  865:    _status = msg.serialize(args);
        9:  866:    FW_ASSERT (
        -:  867:        _status == Fw::FW_SERIALIZE_OK,
        -:  868:        static_cast<AssertArg>(_status)
        -:  869:    );
        -:  870:
        -:  871:    // send message
        9:  872:    Os::Queue::QueueBlocking _block =
        -:  873:      Os::Queue::QUEUE_NONBLOCKING;
        -:  874:    Os::Queue::QueueStatus qStatus =
        9:  875:      this->m_queue.send(msg, 0,_block);
        9:  876:    FW_ASSERT(
        -:  877:        qStatus == Os::Queue::QUEUE_OK,
        -:  878:        static_cast<AssertArg>(qStatus)
        -:  879:    );
        -:  880:
        9:  881:  }
        -:  882:
        9:  883:  void EventActionComponentBase::
        -:  884:    EVAC_REMOVE_preMsgHook(
        -:  885:        FwOpcodeType opCode,
        -:  886:        U32 cmdSeq
        -:  887:    )
        -:  888:  {
        -:  889:    // Defaults to no-op; can be overridden
        9:  890:  }
        -:  891:
        6:  892:  void EventActionComponentBase ::
        -:  893:    EVAC_DUMP_cmdHandlerBase(
        -:  894:        FwOpcodeType opCode,
        -:  895:        U32 cmdSeq,
        -:  896:        Fw::CmdArgBuffer &args
        -:  897:    )
        -:  898:  {
        -:  899:
        -:  900:    // Call pre-message hook
        6:  901:    this->EVAC_DUMP_preMsgHook(opCode,cmdSeq);
        -:  902:
        -:  903:    // Defer deserializing arguments to the message dispatcher
        -:  904:    // to avoid deserializing and reserializing just for IPC
       12:  905:    ComponentIpcSerializableBuffer msg;
        6:  906:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  907:
        -:  908:    // Serialize for IPC
        6:  909:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_EVAC_DUMP);
        6:  910:    FW_ASSERT (
        -:  911:        _status == Fw::FW_SERIALIZE_OK,
        -:  912:        static_cast<AssertArg>(_status)
        -:  913:        );
        -:  914:
        -:  915:    // Fake port number to make message dequeue work
        6:  916:    NATIVE_INT_TYPE port = 0;
        6:  917:    _status = msg.serialize(port);
        6:  918:    FW_ASSERT (
        -:  919:        _status == Fw::FW_SERIALIZE_OK,
        -:  920:        static_cast<AssertArg>(_status)
        -:  921:    );
        -:  922:
        6:  923:    _status = msg.serialize(opCode);
        6:  924:    FW_ASSERT (
        -:  925:        _status == Fw::FW_SERIALIZE_OK,
        -:  926:        static_cast<AssertArg>(_status)
        -:  927:    );
        -:  928:
        6:  929:    _status = msg.serialize(cmdSeq);
        6:  930:    FW_ASSERT (
        -:  931:        _status == Fw::FW_SERIALIZE_OK,
        -:  932:        static_cast<AssertArg>(_status)
        -:  933:    );
        -:  934:
        6:  935:    _status = msg.serialize(args);
        6:  936:    FW_ASSERT (
        -:  937:        _status == Fw::FW_SERIALIZE_OK,
        -:  938:        static_cast<AssertArg>(_status)
        -:  939:    );
        -:  940:
        -:  941:    // send message
        6:  942:    Os::Queue::QueueBlocking _block =
        -:  943:      Os::Queue::QUEUE_NONBLOCKING;
        -:  944:    Os::Queue::QueueStatus qStatus =
        6:  945:      this->m_queue.send(msg, 0,_block);
        6:  946:    FW_ASSERT(
        -:  947:        qStatus == Os::Queue::QUEUE_OK,
        -:  948:        static_cast<AssertArg>(qStatus)
        -:  949:    );
        -:  950:
        6:  951:  }
        -:  952:
        6:  953:  void EventActionComponentBase::
        -:  954:    EVAC_DUMP_preMsgHook(
        -:  955:        FwOpcodeType opCode,
        -:  956:        U32 cmdSeq
        -:  957:    )
        -:  958:  {
        -:  959:    // Defaults to no-op; can be overridden
        6:  960:  }
        -:  961:
        -:  962:  // ----------------------------------------------------------------------
        -:  963:  // Time
        -:  964:  // ----------------------------------------------------------------------
        -:  965:
    #####:  966:  Fw::Time EventActionComponentBase ::
        -:  967:    getTime(void)
        -:  968:  {
    #####:  969:    if (this->m_Time_OutputPort[0].isConnected()) {
    #####:  970:      Fw::Time _time;
    #####:  971:      this->m_Time_OutputPort[0].invoke(_time);
    #####:  972:      return _time;
        -:  973:    } else {
    #####:  974:      return Fw::Time(TB_NONE,0,0);
        -:  975:    }
        -:  976:  }
        -:  977:
        -:  978:  // ----------------------------------------------------------------------
        -:  979:  // Event handling functions
        -:  980:  // ----------------------------------------------------------------------
        -:  981:
       30:  982:  void EventActionComponentBase ::
        -:  983:    log_ACTIVITY_HI_EVAC_ADDED(
        -:  984:        Fw::LogStringArg& sequence, U32 eventId
        -:  985:    )
        -:  986:  {
        -:  987:
        -:  988:
        -:  989:    // Get the time
       60:  990:    Fw::Time _logTime;
       30:  991:    if (this->m_Time_OutputPort[0].isConnected()) {
       30:  992:       this->m_Time_OutputPort[0].invoke( _logTime);
        -:  993:    }
        -:  994:
       30:  995:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -:  996:
       30:  997:    _id = this->getIdBase() + EVENTID_EVAC_ADDED;
        -:  998:
        -:  999:    // Emit the event on the log port
       30: 1000:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1001:
       60: 1002:      Fw::LogBuffer _logBuff;
       30: 1003:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1004:
        -: 1005:#if FW_AMPCS_COMPATIBLE
        -: 1006:      // Serialize the number of arguments
        -: 1007:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1008:      FW_ASSERT(
        -: 1009:          _status == Fw::FW_SERIALIZE_OK,
        -: 1010:          static_cast<AssertArg>(_status)
        -: 1011:      );
        -: 1012:#endif
        -: 1013:
       30: 1014:      sequence.setMaxSerialize(40);
       30: 1015:      _status = _logBuff.serialize(sequence);
       30: 1016:      FW_ASSERT(
        -: 1017:          _status == Fw::FW_SERIALIZE_OK,
        -: 1018:          static_cast<AssertArg>(_status)
        -: 1019:      );
        -: 1020:
        -: 1021:#if FW_AMPCS_COMPATIBLE
        -: 1022:      // Serialize the argument size
        -: 1023:      _status = _logBuff.serialize(
        -: 1024:          static_cast<U8>(sizeof(eventId))
        -: 1025:      );
        -: 1026:      FW_ASSERT(
        -: 1027:          _status == Fw::FW_SERIALIZE_OK,
        -: 1028:          static_cast<AssertArg>(_status)
        -: 1029:      );
        -: 1030:#endif
        -: 1031:
       30: 1032:      _status = _logBuff.serialize(eventId);
       30: 1033:      FW_ASSERT(
        -: 1034:          _status == Fw::FW_SERIALIZE_OK,
        -: 1035:          static_cast<AssertArg>(_status)
        -: 1036:      );
        -: 1037:
        -: 1038:
       30: 1039:      this->m_eventOut_OutputPort[0].invoke(
        -: 1040:          _id,
        -: 1041:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1042:          _logBuff
        -: 1043:      );
        -: 1044:
        -: 1045:    }
        -: 1046:
        -: 1047:    // Emit the event on the text log port
        -: 1048:#if FW_ENABLE_TEXT_LOGGING
       30: 1049:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1050:
        -: 1051:#if FW_OBJECT_NAMES == 1
       30: 1052:      const char* _formatString =
        -: 1053:        "(%s) %s: Sequence %s added for event 0x%02X.";
        -: 1054:#else
        -: 1055:      const char* _formatString =
        -: 1056:        "%s: Sequence %s added for event 0x%02X.";
        -: 1057:#endif
        -: 1058:
        -: 1059:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1060:
       30: 1061:      (void) snprintf(
        -: 1062:          _textBuffer,
        -: 1063:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1064:          _formatString,
        -: 1065:#if FW_OBJECT_NAMES == 1
        -: 1066:          this->m_objName,
        -: 1067:#endif
        -: 1068:          "EVAC_ADDED "
       30: 1069:        , sequence.toChar()
        -: 1070:        , eventId
        -: 1071:      );
        -: 1072:
        -: 1073:      // Null terminate
       30: 1074:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       60: 1075:      Fw::TextLogString _logString = _textBuffer;
       30: 1076:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1077:          _id,
        -: 1078:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1079:          _logString
        -: 1080:      );
        -: 1081:
        -: 1082:    }
        -: 1083:#endif
        -: 1084:
       30: 1085:  }
        -: 1086:
        -: 1087:
        3: 1088:  void EventActionComponentBase ::
        -: 1089:    log_ACTIVITY_HI_EVAC_REMOVED(
        -: 1090:        Fw::LogStringArg& sequence, U32 eventId
        -: 1091:    )
        -: 1092:  {
        -: 1093:
        -: 1094:
        -: 1095:    // Get the time
        6: 1096:    Fw::Time _logTime;
        3: 1097:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 1098:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1099:    }
        -: 1100:
        3: 1101:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1102:
        3: 1103:    _id = this->getIdBase() + EVENTID_EVAC_REMOVED;
        -: 1104:
        -: 1105:    // Emit the event on the log port
        3: 1106:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1107:
        6: 1108:      Fw::LogBuffer _logBuff;
        3: 1109:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1110:
        -: 1111:#if FW_AMPCS_COMPATIBLE
        -: 1112:      // Serialize the number of arguments
        -: 1113:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1114:      FW_ASSERT(
        -: 1115:          _status == Fw::FW_SERIALIZE_OK,
        -: 1116:          static_cast<AssertArg>(_status)
        -: 1117:      );
        -: 1118:#endif
        -: 1119:
        3: 1120:      sequence.setMaxSerialize(40);
        3: 1121:      _status = _logBuff.serialize(sequence);
        3: 1122:      FW_ASSERT(
        -: 1123:          _status == Fw::FW_SERIALIZE_OK,
        -: 1124:          static_cast<AssertArg>(_status)
        -: 1125:      );
        -: 1126:
        -: 1127:#if FW_AMPCS_COMPATIBLE
        -: 1128:      // Serialize the argument size
        -: 1129:      _status = _logBuff.serialize(
        -: 1130:          static_cast<U8>(sizeof(eventId))
        -: 1131:      );
        -: 1132:      FW_ASSERT(
        -: 1133:          _status == Fw::FW_SERIALIZE_OK,
        -: 1134:          static_cast<AssertArg>(_status)
        -: 1135:      );
        -: 1136:#endif
        -: 1137:
        3: 1138:      _status = _logBuff.serialize(eventId);
        3: 1139:      FW_ASSERT(
        -: 1140:          _status == Fw::FW_SERIALIZE_OK,
        -: 1141:          static_cast<AssertArg>(_status)
        -: 1142:      );
        -: 1143:
        -: 1144:
        3: 1145:      this->m_eventOut_OutputPort[0].invoke(
        -: 1146:          _id,
        -: 1147:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1148:          _logBuff
        -: 1149:      );
        -: 1150:
        -: 1151:    }
        -: 1152:
        -: 1153:    // Emit the event on the text log port
        -: 1154:#if FW_ENABLE_TEXT_LOGGING
        3: 1155:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1156:
        -: 1157:#if FW_OBJECT_NAMES == 1
        3: 1158:      const char* _formatString =
        -: 1159:        "(%s) %s: Sequence %s removed for event 0x%02X.";
        -: 1160:#else
        -: 1161:      const char* _formatString =
        -: 1162:        "%s: Sequence %s removed for event 0x%02X.";
        -: 1163:#endif
        -: 1164:
        -: 1165:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1166:
        3: 1167:      (void) snprintf(
        -: 1168:          _textBuffer,
        -: 1169:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1170:          _formatString,
        -: 1171:#if FW_OBJECT_NAMES == 1
        -: 1172:          this->m_objName,
        -: 1173:#endif
        -: 1174:          "EVAC_REMOVED "
        3: 1175:        , sequence.toChar()
        -: 1176:        , eventId
        -: 1177:      );
        -: 1178:
        -: 1179:      // Null terminate
        3: 1180:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        6: 1181:      Fw::TextLogString _logString = _textBuffer;
        3: 1182:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1183:          _id,
        -: 1184:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1185:          _logString
        -: 1186:      );
        -: 1187:
        -: 1188:    }
        -: 1189:#endif
        -: 1190:
        3: 1191:  }
        -: 1192:
        -: 1193:
        3: 1194:  void EventActionComponentBase ::
        -: 1195:    log_WARNING_LO_EVAC_LIST_FULL(
        -: 1196:        U32 eventId
        -: 1197:    )
        -: 1198:  {
        -: 1199:
        -: 1200:
        -: 1201:    // Get the time
        6: 1202:    Fw::Time _logTime;
        3: 1203:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 1204:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1205:    }
        -: 1206:
        3: 1207:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1208:
        3: 1209:    _id = this->getIdBase() + EVENTID_EVAC_LIST_FULL;
        -: 1210:
        -: 1211:    // Emit the event on the log port
        3: 1212:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1213:
        6: 1214:      Fw::LogBuffer _logBuff;
        3: 1215:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1216:
        -: 1217:#if FW_AMPCS_COMPATIBLE
        -: 1218:      // Serialize the number of arguments
        -: 1219:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1220:      FW_ASSERT(
        -: 1221:          _status == Fw::FW_SERIALIZE_OK,
        -: 1222:          static_cast<AssertArg>(_status)
        -: 1223:      );
        -: 1224:#endif
        -: 1225:
        -: 1226:#if FW_AMPCS_COMPATIBLE
        -: 1227:      // Serialize the argument size
        -: 1228:      _status = _logBuff.serialize(
        -: 1229:          static_cast<U8>(sizeof(eventId))
        -: 1230:      );
        -: 1231:      FW_ASSERT(
        -: 1232:          _status == Fw::FW_SERIALIZE_OK,
        -: 1233:          static_cast<AssertArg>(_status)
        -: 1234:      );
        -: 1235:#endif
        -: 1236:
        3: 1237:      _status = _logBuff.serialize(eventId);
        3: 1238:      FW_ASSERT(
        -: 1239:          _status == Fw::FW_SERIALIZE_OK,
        -: 1240:          static_cast<AssertArg>(_status)
        -: 1241:      );
        -: 1242:
        -: 1243:
        3: 1244:      this->m_eventOut_OutputPort[0].invoke(
        -: 1245:          _id,
        -: 1246:          _logTime,Fw::LOG_WARNING_LO,
        -: 1247:          _logBuff
        -: 1248:      );
        -: 1249:
        -: 1250:    }
        -: 1251:
        -: 1252:    // Emit the event on the text log port
        -: 1253:#if FW_ENABLE_TEXT_LOGGING
        3: 1254:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1255:
        -: 1256:#if FW_OBJECT_NAMES == 1
        3: 1257:      const char* _formatString =
        -: 1258:        "(%s) %s: Unable to add sequence for event 0x%02X, list full.";
        -: 1259:#else
        -: 1260:      const char* _formatString =
        -: 1261:        "%s: Unable to add sequence for event 0x%02X, list full.";
        -: 1262:#endif
        -: 1263:
        -: 1264:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1265:
        3: 1266:      (void) snprintf(
        -: 1267:          _textBuffer,
        -: 1268:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1269:          _formatString,
        -: 1270:#if FW_OBJECT_NAMES == 1
        -: 1271:          this->m_objName,
        -: 1272:#endif
        -: 1273:          "EVAC_LIST_FULL "
        -: 1274:        , eventId
        -: 1275:      );
        -: 1276:
        -: 1277:      // Null terminate
        3: 1278:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        6: 1279:      Fw::TextLogString _logString = _textBuffer;
        3: 1280:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1281:          _id,
        -: 1282:          _logTime,Fw::TEXT_LOG_WARNING_LO,
        -: 1283:          _logString
        -: 1284:      );
        -: 1285:
        -: 1286:    }
        -: 1287:#endif
        -: 1288:
        3: 1289:  }
        -: 1290:
        -: 1291:
        6: 1292:  void EventActionComponentBase ::
        -: 1293:    log_WARNING_LO_EVAC_NOT_FOUND(
        -: 1294:        U32 eventId
        -: 1295:    )
        -: 1296:  {
        -: 1297:
        -: 1298:
        -: 1299:    // Get the time
       12: 1300:    Fw::Time _logTime;
        6: 1301:    if (this->m_Time_OutputPort[0].isConnected()) {
        6: 1302:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1303:    }
        -: 1304:
        6: 1305:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1306:
        6: 1307:    _id = this->getIdBase() + EVENTID_EVAC_NOT_FOUND;
        -: 1308:
        -: 1309:    // Emit the event on the log port
        6: 1310:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1311:
       12: 1312:      Fw::LogBuffer _logBuff;
        6: 1313:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1314:
        -: 1315:#if FW_AMPCS_COMPATIBLE
        -: 1316:      // Serialize the number of arguments
        -: 1317:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1318:      FW_ASSERT(
        -: 1319:          _status == Fw::FW_SERIALIZE_OK,
        -: 1320:          static_cast<AssertArg>(_status)
        -: 1321:      );
        -: 1322:#endif
        -: 1323:
        -: 1324:#if FW_AMPCS_COMPATIBLE
        -: 1325:      // Serialize the argument size
        -: 1326:      _status = _logBuff.serialize(
        -: 1327:          static_cast<U8>(sizeof(eventId))
        -: 1328:      );
        -: 1329:      FW_ASSERT(
        -: 1330:          _status == Fw::FW_SERIALIZE_OK,
        -: 1331:          static_cast<AssertArg>(_status)
        -: 1332:      );
        -: 1333:#endif
        -: 1334:
        6: 1335:      _status = _logBuff.serialize(eventId);
        6: 1336:      FW_ASSERT(
        -: 1337:          _status == Fw::FW_SERIALIZE_OK,
        -: 1338:          static_cast<AssertArg>(_status)
        -: 1339:      );
        -: 1340:
        -: 1341:
        6: 1342:      this->m_eventOut_OutputPort[0].invoke(
        -: 1343:          _id,
        -: 1344:          _logTime,Fw::LOG_WARNING_LO,
        -: 1345:          _logBuff
        -: 1346:      );
        -: 1347:
        -: 1348:    }
        -: 1349:
        -: 1350:    // Emit the event on the text log port
        -: 1351:#if FW_ENABLE_TEXT_LOGGING
        6: 1352:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1353:
        -: 1354:#if FW_OBJECT_NAMES == 1
        6: 1355:      const char* _formatString =
        -: 1356:        "(%s) %s: Unable to remove sequence for event 0x%02X, not found.";
        -: 1357:#else
        -: 1358:      const char* _formatString =
        -: 1359:        "%s: Unable to remove sequence for event 0x%02X, not found.";
        -: 1360:#endif
        -: 1361:
        -: 1362:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1363:
        6: 1364:      (void) snprintf(
        -: 1365:          _textBuffer,
        -: 1366:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1367:          _formatString,
        -: 1368:#if FW_OBJECT_NAMES == 1
        -: 1369:          this->m_objName,
        -: 1370:#endif
        -: 1371:          "EVAC_NOT_FOUND "
        -: 1372:        , eventId
        -: 1373:      );
        -: 1374:
        -: 1375:      // Null terminate
        6: 1376:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       12: 1377:      Fw::TextLogString _logString = _textBuffer;
        6: 1378:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1379:          _id,
        -: 1380:          _logTime,Fw::TEXT_LOG_WARNING_LO,
        -: 1381:          _logString
        -: 1382:      );
        -: 1383:
        -: 1384:    }
        -: 1385:#endif
        -: 1386:
        6: 1387:  }
        -: 1388:
        -: 1389:
        3: 1390:  void EventActionComponentBase ::
        -: 1391:    log_WARNING_HI_EVAC_ALREADY_REGISTERED(
        -: 1392:        U32 eventId, Fw::LogStringArg& sequence
        -: 1393:    )
        -: 1394:  {
        -: 1395:
        -: 1396:
        -: 1397:    // Get the time
        6: 1398:    Fw::Time _logTime;
        3: 1399:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 1400:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1401:    }
        -: 1402:
        3: 1403:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1404:
        3: 1405:    _id = this->getIdBase() + EVENTID_EVAC_ALREADY_REGISTERED;
        -: 1406:
        -: 1407:    // Emit the event on the log port
        3: 1408:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1409:
        6: 1410:      Fw::LogBuffer _logBuff;
        3: 1411:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1412:
        -: 1413:#if FW_AMPCS_COMPATIBLE
        -: 1414:      // Serialize the number of arguments
        -: 1415:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1416:      FW_ASSERT(
        -: 1417:          _status == Fw::FW_SERIALIZE_OK,
        -: 1418:          static_cast<AssertArg>(_status)
        -: 1419:      );
        -: 1420:#endif
        -: 1421:
        -: 1422:#if FW_AMPCS_COMPATIBLE
        -: 1423:      // Serialize the argument size
        -: 1424:      _status = _logBuff.serialize(
        -: 1425:          static_cast<U8>(sizeof(eventId))
        -: 1426:      );
        -: 1427:      FW_ASSERT(
        -: 1428:          _status == Fw::FW_SERIALIZE_OK,
        -: 1429:          static_cast<AssertArg>(_status)
        -: 1430:      );
        -: 1431:#endif
        -: 1432:
        3: 1433:      _status = _logBuff.serialize(eventId);
        3: 1434:      FW_ASSERT(
        -: 1435:          _status == Fw::FW_SERIALIZE_OK,
        -: 1436:          static_cast<AssertArg>(_status)
        -: 1437:      );
        -: 1438:
        3: 1439:      sequence.setMaxSerialize(40);
        3: 1440:      _status = _logBuff.serialize(sequence);
        3: 1441:      FW_ASSERT(
        -: 1442:          _status == Fw::FW_SERIALIZE_OK,
        -: 1443:          static_cast<AssertArg>(_status)
        -: 1444:      );
        -: 1445:
        -: 1446:
        3: 1447:      this->m_eventOut_OutputPort[0].invoke(
        -: 1448:          _id,
        -: 1449:          _logTime,Fw::LOG_WARNING_HI,
        -: 1450:          _logBuff
        -: 1451:      );
        -: 1452:
        -: 1453:    }
        -: 1454:
        -: 1455:    // Emit the event on the text log port
        -: 1456:#if FW_ENABLE_TEXT_LOGGING
        3: 1457:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1458:
        -: 1459:#if FW_OBJECT_NAMES == 1
        3: 1460:      const char* _formatString =
        -: 1461:        "(%s) %s: Unable to add sequence - Event 0x%02X already registered for sequence %s";
        -: 1462:#else
        -: 1463:      const char* _formatString =
        -: 1464:        "%s: Unable to add sequence - Event 0x%02X already registered for sequence %s";
        -: 1465:#endif
        -: 1466:
        -: 1467:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1468:
        3: 1469:      (void) snprintf(
        -: 1470:          _textBuffer,
        -: 1471:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1472:          _formatString,
        -: 1473:#if FW_OBJECT_NAMES == 1
        -: 1474:          this->m_objName,
        -: 1475:#endif
        -: 1476:          "EVAC_ALREADY_REGISTERED "
        -: 1477:        , eventId
        3: 1478:        , sequence.toChar()
        -: 1479:      );
        -: 1480:
        -: 1481:      // Null terminate
        3: 1482:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        6: 1483:      Fw::TextLogString _logString = _textBuffer;
        3: 1484:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1485:          _id,
        -: 1486:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 1487:          _logString
        -: 1488:      );
        -: 1489:
        -: 1490:    }
        -: 1491:#endif
        -: 1492:
        3: 1493:  }
        -: 1494:
        -: 1495:
        6: 1496:  void EventActionComponentBase ::
        -: 1497:    log_ACTIVITY_HI_EVAC_DUMP(
        -: 1498:        Fw::LogStringArg& sequence, U32 eventId
        -: 1499:    )
        -: 1500:  {
        -: 1501:
        -: 1502:
        -: 1503:    // Get the time
       12: 1504:    Fw::Time _logTime;
        6: 1505:    if (this->m_Time_OutputPort[0].isConnected()) {
        6: 1506:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1507:    }
        -: 1508:
        6: 1509:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1510:
        6: 1511:    _id = this->getIdBase() + EVENTID_EVAC_DUMP;
        -: 1512:
        -: 1513:    // Emit the event on the log port
        6: 1514:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1515:
       12: 1516:      Fw::LogBuffer _logBuff;
        6: 1517:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1518:
        -: 1519:#if FW_AMPCS_COMPATIBLE
        -: 1520:      // Serialize the number of arguments
        -: 1521:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1522:      FW_ASSERT(
        -: 1523:          _status == Fw::FW_SERIALIZE_OK,
        -: 1524:          static_cast<AssertArg>(_status)
        -: 1525:      );
        -: 1526:#endif
        -: 1527:
        6: 1528:      sequence.setMaxSerialize(40);
        6: 1529:      _status = _logBuff.serialize(sequence);
        6: 1530:      FW_ASSERT(
        -: 1531:          _status == Fw::FW_SERIALIZE_OK,
        -: 1532:          static_cast<AssertArg>(_status)
        -: 1533:      );
        -: 1534:
        -: 1535:#if FW_AMPCS_COMPATIBLE
        -: 1536:      // Serialize the argument size
        -: 1537:      _status = _logBuff.serialize(
        -: 1538:          static_cast<U8>(sizeof(eventId))
        -: 1539:      );
        -: 1540:      FW_ASSERT(
        -: 1541:          _status == Fw::FW_SERIALIZE_OK,
        -: 1542:          static_cast<AssertArg>(_status)
        -: 1543:      );
        -: 1544:#endif
        -: 1545:
        6: 1546:      _status = _logBuff.serialize(eventId);
        6: 1547:      FW_ASSERT(
        -: 1548:          _status == Fw::FW_SERIALIZE_OK,
        -: 1549:          static_cast<AssertArg>(_status)
        -: 1550:      );
        -: 1551:
        -: 1552:
        6: 1553:      this->m_eventOut_OutputPort[0].invoke(
        -: 1554:          _id,
        -: 1555:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1556:          _logBuff
        -: 1557:      );
        -: 1558:
        -: 1559:    }
        -: 1560:
        -: 1561:    // Emit the event on the text log port
        -: 1562:#if FW_ENABLE_TEXT_LOGGING
        6: 1563:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1564:
        -: 1565:#if FW_OBJECT_NAMES == 1
        6: 1566:      const char* _formatString =
        -: 1567:        "(%s) %s: Sequence %s registered for event 0x%02X";
        -: 1568:#else
        -: 1569:      const char* _formatString =
        -: 1570:        "%s: Sequence %s registered for event 0x%02X";
        -: 1571:#endif
        -: 1572:
        -: 1573:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1574:
        6: 1575:      (void) snprintf(
        -: 1576:          _textBuffer,
        -: 1577:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1578:          _formatString,
        -: 1579:#if FW_OBJECT_NAMES == 1
        -: 1580:          this->m_objName,
        -: 1581:#endif
        -: 1582:          "EVAC_DUMP "
        6: 1583:        , sequence.toChar()
        -: 1584:        , eventId
        -: 1585:      );
        -: 1586:
        -: 1587:      // Null terminate
        6: 1588:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       12: 1589:      Fw::TextLogString _logString = _textBuffer;
        6: 1590:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1591:          _id,
        -: 1592:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1593:          _logString
        -: 1594:      );
        -: 1595:
        -: 1596:    }
        -: 1597:#endif
        -: 1598:
        6: 1599:  }
        -: 1600:
        -: 1601:
        3: 1602:  void EventActionComponentBase ::
        -: 1603:    log_ACTIVITY_HI_EVAC_RUN(
        -: 1604:        U32 eventId, Fw::LogStringArg& sequence
        -: 1605:    )
        -: 1606:  {
        -: 1607:
        -: 1608:
        -: 1609:    // Get the time
        6: 1610:    Fw::Time _logTime;
        3: 1611:    if (this->m_Time_OutputPort[0].isConnected()) {
        3: 1612:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1613:    }
        -: 1614:
        3: 1615:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1616:
        3: 1617:    _id = this->getIdBase() + EVENTID_EVAC_RUN;
        -: 1618:
        -: 1619:    // Emit the event on the log port
        3: 1620:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1621:
        6: 1622:      Fw::LogBuffer _logBuff;
        3: 1623:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1624:
        -: 1625:#if FW_AMPCS_COMPATIBLE
        -: 1626:      // Serialize the number of arguments
        -: 1627:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1628:      FW_ASSERT(
        -: 1629:          _status == Fw::FW_SERIALIZE_OK,
        -: 1630:          static_cast<AssertArg>(_status)
        -: 1631:      );
        -: 1632:#endif
        -: 1633:
        -: 1634:#if FW_AMPCS_COMPATIBLE
        -: 1635:      // Serialize the argument size
        -: 1636:      _status = _logBuff.serialize(
        -: 1637:          static_cast<U8>(sizeof(eventId))
        -: 1638:      );
        -: 1639:      FW_ASSERT(
        -: 1640:          _status == Fw::FW_SERIALIZE_OK,
        -: 1641:          static_cast<AssertArg>(_status)
        -: 1642:      );
        -: 1643:#endif
        -: 1644:
        3: 1645:      _status = _logBuff.serialize(eventId);
        3: 1646:      FW_ASSERT(
        -: 1647:          _status == Fw::FW_SERIALIZE_OK,
        -: 1648:          static_cast<AssertArg>(_status)
        -: 1649:      );
        -: 1650:
        3: 1651:      sequence.setMaxSerialize(40);
        3: 1652:      _status = _logBuff.serialize(sequence);
        3: 1653:      FW_ASSERT(
        -: 1654:          _status == Fw::FW_SERIALIZE_OK,
        -: 1655:          static_cast<AssertArg>(_status)
        -: 1656:      );
        -: 1657:
        -: 1658:
        3: 1659:      this->m_eventOut_OutputPort[0].invoke(
        -: 1660:          _id,
        -: 1661:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1662:          _logBuff
        -: 1663:      );
        -: 1664:
        -: 1665:    }
        -: 1666:
        -: 1667:    // Emit the event on the text log port
        -: 1668:#if FW_ENABLE_TEXT_LOGGING
        3: 1669:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1670:
        -: 1671:#if FW_OBJECT_NAMES == 1
        3: 1672:      const char* _formatString =
        -: 1673:        "(%s) %s: Event 0x%02X received - Running sequence %s";
        -: 1674:#else
        -: 1675:      const char* _formatString =
        -: 1676:        "%s: Event 0x%02X received - Running sequence %s";
        -: 1677:#endif
        -: 1678:
        -: 1679:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1680:
        3: 1681:      (void) snprintf(
        -: 1682:          _textBuffer,
        -: 1683:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1684:          _formatString,
        -: 1685:#if FW_OBJECT_NAMES == 1
        -: 1686:          this->m_objName,
        -: 1687:#endif
        -: 1688:          "EVAC_RUN "
        -: 1689:        , eventId
        3: 1690:        , sequence.toChar()
        -: 1691:      );
        -: 1692:
        -: 1693:      // Null terminate
        3: 1694:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
        6: 1695:      Fw::TextLogString _logString = _textBuffer;
        3: 1696:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1697:          _id,
        -: 1698:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1699:          _logString
        -: 1700:      );
        -: 1701:
        -: 1702:    }
        -: 1703:#endif
        -: 1704:
        3: 1705:  }
        -: 1706:
        -: 1707:
        -: 1708:  // ----------------------------------------------------------------------
        -: 1709:  // Calls for invocations received on typed input ports
        -: 1710:  // ----------------------------------------------------------------------
        -: 1711:
    #####: 1712:  void EventActionComponentBase ::
        -: 1713:    m_p_seqResp_in(
        -: 1714:        Fw::PassiveComponentBase* callComp,
        -: 1715:        NATIVE_INT_TYPE portNum,
        -: 1716:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 1717:    )
        -: 1718:  {
    #####: 1719:    FW_ASSERT(callComp);
    #####: 1720:    EventActionComponentBase* compPtr =
        -: 1721:      (EventActionComponentBase*) callComp;
    #####: 1722:    compPtr->seqResp_handlerBase(portNum, opCode, cmdSeq, response);
    #####: 1723:  }
        -: 1724:
        6: 1725:  void EventActionComponentBase ::
        -: 1726:    m_p_logRecv_in(
        -: 1727:        Fw::PassiveComponentBase* callComp,
        -: 1728:        NATIVE_INT_TYPE portNum,
        -: 1729:        FwEventIdType id, Fw::Time &timeTag, Fw::LogSeverity severity, Fw::LogBuffer &args
        -: 1730:    )
        -: 1731:  {
        6: 1732:    FW_ASSERT(callComp);
        6: 1733:    EventActionComponentBase* compPtr =
        -: 1734:      (EventActionComponentBase*) callComp;
        6: 1735:    compPtr->logRecv_handlerBase(portNum, id, timeTag, severity, args);
        6: 1736:  }
        -: 1737:
        -: 1738:  // ----------------------------------------------------------------------
        -: 1739:  // Port handler base-class functions for typed input ports
        -: 1740:  // ----------------------------------------------------------------------
        -: 1741:
    #####: 1742:  void EventActionComponentBase ::
        -: 1743:    seqResp_handlerBase(
        -: 1744:        NATIVE_INT_TYPE portNum,
        -: 1745:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 1746:    )
        -: 1747:  {
        -: 1748:
        -: 1749:    // Make sure port number is valid
    #####: 1750:    FW_ASSERT(portNum < this->getNum_seqResp_InputPorts(),static_cast<AssertArg>(portNum));
        -: 1751:
        -: 1752:    // Call pre-message hook
    #####: 1753:    seqResp_preMsgHook(
        -: 1754:        portNum,
        -: 1755:        opCode, cmdSeq, response
    #####: 1756:    );
        -: 1757:
    #####: 1758:    ComponentIpcSerializableBuffer msg;
    #####: 1759:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1760:
    #####: 1761:    _status = msg.serialize(
        -: 1762:        static_cast<NATIVE_INT_TYPE>(SEQRESP_CMDRESPONSE)
        -: 1763:    );
    #####: 1764:    FW_ASSERT (
        -: 1765:        _status == Fw::FW_SERIALIZE_OK,
        -: 1766:        static_cast<AssertArg>(_status)
        -: 1767:    );
        -: 1768:
    #####: 1769:    _status = msg.serialize(portNum);
    #####: 1770:    FW_ASSERT (
        -: 1771:        _status == Fw::FW_SERIALIZE_OK,
        -: 1772:        static_cast<AssertArg>(_status)
        -: 1773:    );
        -: 1774:
        -: 1775:    // Serialize argument opCode
    #####: 1776:    _status = msg.serialize(opCode);
    #####: 1777:    FW_ASSERT(
        -: 1778:        _status == Fw::FW_SERIALIZE_OK,
        -: 1779:        static_cast<AssertArg>(_status)
        -: 1780:    );
        -: 1781:
        -: 1782:    // Serialize argument cmdSeq
    #####: 1783:    _status = msg.serialize(cmdSeq);
    #####: 1784:    FW_ASSERT(
        -: 1785:        _status == Fw::FW_SERIALIZE_OK,
        -: 1786:        static_cast<AssertArg>(_status)
        -: 1787:    );
        -: 1788:
        -: 1789:    // Serialize argument response
    #####: 1790:    _status = msg.serialize(static_cast<FwEnumStoreType>(response));
    #####: 1791:    FW_ASSERT(
        -: 1792:        _status == Fw::FW_SERIALIZE_OK,
        -: 1793:        static_cast<AssertArg>(_status)
        -: 1794:    );
        -: 1795:
        -: 1796:
        -: 1797:    // send message
    #####: 1798:    Os::Queue::QueueBlocking _block =
        -: 1799:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1800:    Os::Queue::QueueStatus qStatus =
    #####: 1801:      this->m_queue.send(msg, 0,_block);
    #####: 1802:    FW_ASSERT(
        -: 1803:        qStatus == Os::Queue::QUEUE_OK,
        -: 1804:        static_cast<AssertArg>(qStatus)
        -: 1805:    );
        -: 1806:
    #####: 1807:  }
        -: 1808:
        6: 1809:  void EventActionComponentBase ::
        -: 1810:    logRecv_handlerBase(
        -: 1811:        NATIVE_INT_TYPE portNum,
        -: 1812:        FwEventIdType id, Fw::Time &timeTag, Fw::LogSeverity severity, Fw::LogBuffer &args
        -: 1813:    )
        -: 1814:  {
        -: 1815:
        -: 1816:    // Make sure port number is valid
        6: 1817:    FW_ASSERT(portNum < this->getNum_logRecv_InputPorts(),static_cast<AssertArg>(portNum));
        -: 1818:
        -: 1819:    // Call pre-message hook
        6: 1820:    logRecv_preMsgHook(
        -: 1821:        portNum,
        -: 1822:        id, timeTag, severity, args
        6: 1823:    );
        -: 1824:
       12: 1825:    ComponentIpcSerializableBuffer msg;
        6: 1826:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1827:
        6: 1828:    _status = msg.serialize(
        -: 1829:        static_cast<NATIVE_INT_TYPE>(LOGRECV_LOG)
        -: 1830:    );
        6: 1831:    FW_ASSERT (
        -: 1832:        _status == Fw::FW_SERIALIZE_OK,
        -: 1833:        static_cast<AssertArg>(_status)
        -: 1834:    );
        -: 1835:
        6: 1836:    _status = msg.serialize(portNum);
        6: 1837:    FW_ASSERT (
        -: 1838:        _status == Fw::FW_SERIALIZE_OK,
        -: 1839:        static_cast<AssertArg>(_status)
        -: 1840:    );
        -: 1841:
        -: 1842:    // Serialize argument id
        6: 1843:    _status = msg.serialize(id);
        6: 1844:    FW_ASSERT(
        -: 1845:        _status == Fw::FW_SERIALIZE_OK,
        -: 1846:        static_cast<AssertArg>(_status)
        -: 1847:    );
        -: 1848:
        -: 1849:    // Serialize argument timeTag
        6: 1850:    _status = msg.serialize(timeTag);
        6: 1851:    FW_ASSERT(
        -: 1852:        _status == Fw::FW_SERIALIZE_OK,
        -: 1853:        static_cast<AssertArg>(_status)
        -: 1854:    );
        -: 1855:
        -: 1856:    // Serialize argument severity
        6: 1857:    _status = msg.serialize(static_cast<FwEnumStoreType>(severity));
        6: 1858:    FW_ASSERT(
        -: 1859:        _status == Fw::FW_SERIALIZE_OK,
        -: 1860:        static_cast<AssertArg>(_status)
        -: 1861:    );
        -: 1862:
        -: 1863:    // Serialize argument args
        6: 1864:    _status = msg.serialize(args);
        6: 1865:    FW_ASSERT(
        -: 1866:        _status == Fw::FW_SERIALIZE_OK,
        -: 1867:        static_cast<AssertArg>(_status)
        -: 1868:    );
        -: 1869:
        -: 1870:
        -: 1871:    // send message
        6: 1872:    Os::Queue::QueueBlocking _block =
        -: 1873:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1874:    Os::Queue::QueueStatus qStatus =
        6: 1875:      this->m_queue.send(msg, 0,_block);
        6: 1876:    FW_ASSERT(
        -: 1877:        qStatus == Os::Queue::QUEUE_OK,
        -: 1878:        static_cast<AssertArg>(qStatus)
        -: 1879:    );
        -: 1880:
        6: 1881:  }
        -: 1882:
        -: 1883:  // ----------------------------------------------------------------------
        -: 1884:  // Pre-message hooks for async input ports
        -: 1885:  // ----------------------------------------------------------------------
        -: 1886:
    #####: 1887:  void EventActionComponentBase ::
        -: 1888:    seqResp_preMsgHook(
        -: 1889:        NATIVE_INT_TYPE portNum,
        -: 1890:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 1891:    )
        -: 1892:  {
        -: 1893:    // Default: no-op
    #####: 1894:  }
        -: 1895:
        6: 1896:  void EventActionComponentBase ::
        -: 1897:    logRecv_preMsgHook(
        -: 1898:        NATIVE_INT_TYPE portNum,
        -: 1899:        FwEventIdType id, Fw::Time &timeTag, Fw::LogSeverity severity, Fw::LogBuffer &args
        -: 1900:    )
        -: 1901:  {
        -: 1902:    // Default: no-op
        6: 1903:  }
        -: 1904:
        -: 1905:  // ----------------------------------------------------------------------
        -: 1906:  // Message dispatch method for active and queued components. Called
        -: 1907:  // by active component thread or implementation code for queued components
        -: 1908:  // ----------------------------------------------------------------------
        -: 1909:
       57: 1910:  Fw::QueuedComponentBase::MsgDispatchStatus EventActionComponentBase ::
        -: 1911:    doDispatch(void)
        -: 1912:  {
      114: 1913:    ComponentIpcSerializableBuffer msg;
        -: 1914:    NATIVE_INT_TYPE priority;
        -: 1915:
       57: 1916:    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority,Os::Queue::QUEUE_BLOCKING);
       57: 1917:    FW_ASSERT(
        -: 1918:        msgStatus == Os::Queue::QUEUE_OK,
        -: 1919:        static_cast<AssertArg>(msgStatus)
        -: 1920:    );
        -: 1921:
        -: 1922:    // Reset to beginning of buffer
       57: 1923:    msg.resetDeser();
        -: 1924:
        -: 1925:    NATIVE_INT_TYPE desMsg;
       57: 1926:    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
       57: 1927:    FW_ASSERT(
        -: 1928:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1929:        static_cast<AssertArg>(deserStatus)
        -: 1930:    );
        -: 1931:
       57: 1932:    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);
        -: 1933:
       57: 1934:    if (msgType == EVENTACTION_COMPONENT_EXIT) {
    #####: 1935:      return MSG_DISPATCH_EXIT;
        -: 1936:    }
        -: 1937:
        -: 1938:    NATIVE_INT_TYPE portNum;
       57: 1939:    deserStatus = msg.deserialize(portNum);
       57: 1940:    FW_ASSERT(
        -: 1941:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1942:        static_cast<AssertArg>(deserStatus)
        -: 1943:    );
        -: 1944:
       57: 1945:    switch (msgType) {
        -: 1946:
        -: 1947:      // Handle async input port seqResp
    #####: 1948:      case SEQRESP_CMDRESPONSE: {
        -: 1949:
        -: 1950:        // Deserialize argument opCode
        -: 1951:        FwOpcodeType opCode;
    #####: 1952:        deserStatus = msg.deserialize(opCode);
    #####: 1953:        FW_ASSERT(
        -: 1954:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1955:            static_cast<AssertArg>(deserStatus)
        -: 1956:        );
        -: 1957:
        -: 1958:        // Deserialize argument cmdSeq
        -: 1959:        U32 cmdSeq;
    #####: 1960:        deserStatus = msg.deserialize(cmdSeq);
    #####: 1961:        FW_ASSERT(
        -: 1962:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1963:            static_cast<AssertArg>(deserStatus)
        -: 1964:        );
        -: 1965:
        -: 1966:        // Deserialize argument response
        -: 1967:        Fw::CommandResponse response;
        -: 1968:        FwEnumStoreType responseInt;
    #####: 1969:        deserStatus = msg.deserialize(responseInt);
    #####: 1970:        response = (Fw::CommandResponse) responseInt;
    #####: 1971:        FW_ASSERT(
        -: 1972:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1973:            static_cast<AssertArg>(deserStatus)
        -: 1974:        );
        -: 1975:
        -: 1976:        // Call handler function
    #####: 1977:        this->seqResp_handler(
        -: 1978:            portNum,
        -: 1979:            opCode, cmdSeq, response
    #####: 1980:        );
        -: 1981:
    #####: 1982:        break;
        -: 1983:
        -: 1984:      }
        -: 1985:
        -: 1986:      // Handle async input port logRecv
        6: 1987:      case LOGRECV_LOG: {
        -: 1988:
        -: 1989:        // Deserialize argument id
        -: 1990:        FwEventIdType id;
        6: 1991:        deserStatus = msg.deserialize(id);
        6: 1992:        FW_ASSERT(
        -: 1993:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 1994:            static_cast<AssertArg>(deserStatus)
        -: 1995:        );
        -: 1996:
        -: 1997:        // Deserialize argument timeTag
       12: 1998:        Fw::Time timeTag;
        6: 1999:        deserStatus = msg.deserialize(timeTag);
        6: 2000:        FW_ASSERT(
        -: 2001:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2002:            static_cast<AssertArg>(deserStatus)
        -: 2003:        );
        -: 2004:
        -: 2005:        // Deserialize argument severity
        -: 2006:        Fw::LogSeverity severity;
        -: 2007:        FwEnumStoreType severityInt;
        6: 2008:        deserStatus = msg.deserialize(severityInt);
        6: 2009:        severity = (Fw::LogSeverity) severityInt;
        6: 2010:        FW_ASSERT(
        -: 2011:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2012:            static_cast<AssertArg>(deserStatus)
        -: 2013:        );
        -: 2014:
        -: 2015:        // Deserialize argument args
       12: 2016:        Fw::LogBuffer args;
        6: 2017:        deserStatus = msg.deserialize(args);
        6: 2018:        FW_ASSERT(
        -: 2019:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2020:            static_cast<AssertArg>(deserStatus)
        -: 2021:        );
        -: 2022:
        -: 2023:        // Call handler function
        6: 2024:        this->logRecv_handler(
        -: 2025:            portNum,
        -: 2026:            id, timeTag, severity, args
        6: 2027:        );
        -: 2028:
        6: 2029:        break;
        -: 2030:
        -: 2031:      }
        -: 2032:
        -: 2033:      // Handle command EVAC_ADD
       36: 2034:      case CMD_EVAC_ADD: {
        -: 2035:        // Deserialize opcode
        -: 2036:        FwOpcodeType opCode;
       36: 2037:        deserStatus = msg.deserialize(opCode);
       36: 2038:        FW_ASSERT (
        -: 2039:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2040:            static_cast<AssertArg>(deserStatus)
        -: 2041:        );
        -: 2042:
        -: 2043:        // Deserialize command sequence
        -: 2044:        U32 cmdSeq;
       36: 2045:        deserStatus = msg.deserialize(cmdSeq);
       36: 2046:        FW_ASSERT (
        -: 2047:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2048:            static_cast<AssertArg>(deserStatus)
        -: 2049:        );
        -: 2050:
        -: 2051:        // Deserialize command argument buffer
       72: 2052:        Fw::CmdArgBuffer args;
       36: 2053:        deserStatus = msg.deserialize(args);
       36: 2054:        FW_ASSERT (
        -: 2055:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2056:            static_cast<AssertArg>(deserStatus)
        -: 2057:        );
        -: 2058:
        -: 2059:        // Reset buffer
       36: 2060:        args.resetDeser();
        -: 2061:
        -: 2062:        // Deserialize argument id
        -: 2063:        U32 id;
       36: 2064:        deserStatus = args.deserialize(id);
       36: 2065:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2066:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2067:            this->cmdResponse_out(
        -: 2068:                opCode,
        -: 2069:                cmdSeq,
        -: 2070:                Fw::COMMAND_FORMAT_ERROR
        -: 2071:            );
        -: 2072:          }
        -: 2073:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2074:          break;
        -: 2075:        }
        -: 2076:
        -: 2077:        // Deserialize argument sequence
       72: 2078:        Fw::CmdStringArg sequence;
       36: 2079:        deserStatus = args.deserialize(sequence);
       36: 2080:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2081:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2082:            this->cmdResponse_out(
        -: 2083:                opCode,
        -: 2084:                cmdSeq,
        -: 2085:                Fw::COMMAND_FORMAT_ERROR
        -: 2086:            );
        -: 2087:          }
        -: 2088:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2089:          break;
        -: 2090:        }
        -: 2091:
        -: 2092:        // Make sure there was no data left over.
        -: 2093:        // That means the argument buffer size was incorrect.
        -: 2094:#if FW_CMD_CHECK_RESIDUAL
       36: 2095:        if (args.getBuffLeft() != 0) {
    #####: 2096:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2097:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2098:          }
        -: 2099:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2100:          break;
        -: 2101:        }
        -: 2102:#endif
        -: 2103:        // Call handler function
       36: 2104:        this->EVAC_ADD_cmdHandler(
        -: 2105:            opCode,
        -: 2106:            cmdSeq,
        -: 2107:            id, sequence
       36: 2108:        );
        -: 2109:
       36: 2110:        break;
        -: 2111:
        -: 2112:      }
        -: 2113:
        -: 2114:      // Handle command EVAC_REMOVE
        9: 2115:      case CMD_EVAC_REMOVE: {
        -: 2116:        // Deserialize opcode
        -: 2117:        FwOpcodeType opCode;
        9: 2118:        deserStatus = msg.deserialize(opCode);
        9: 2119:        FW_ASSERT (
        -: 2120:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2121:            static_cast<AssertArg>(deserStatus)
        -: 2122:        );
        -: 2123:
        -: 2124:        // Deserialize command sequence
        -: 2125:        U32 cmdSeq;
        9: 2126:        deserStatus = msg.deserialize(cmdSeq);
        9: 2127:        FW_ASSERT (
        -: 2128:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2129:            static_cast<AssertArg>(deserStatus)
        -: 2130:        );
        -: 2131:
        -: 2132:        // Deserialize command argument buffer
       18: 2133:        Fw::CmdArgBuffer args;
        9: 2134:        deserStatus = msg.deserialize(args);
        9: 2135:        FW_ASSERT (
        -: 2136:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2137:            static_cast<AssertArg>(deserStatus)
        -: 2138:        );
        -: 2139:
        -: 2140:        // Reset buffer
        9: 2141:        args.resetDeser();
        -: 2142:
        -: 2143:        // Deserialize argument id
        -: 2144:        U32 id;
        9: 2145:        deserStatus = args.deserialize(id);
        9: 2146:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2147:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2148:            this->cmdResponse_out(
        -: 2149:                opCode,
        -: 2150:                cmdSeq,
        -: 2151:                Fw::COMMAND_FORMAT_ERROR
        -: 2152:            );
        -: 2153:          }
        -: 2154:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2155:          break;
        -: 2156:        }
        -: 2157:
        -: 2158:        // Make sure there was no data left over.
        -: 2159:        // That means the argument buffer size was incorrect.
        -: 2160:#if FW_CMD_CHECK_RESIDUAL
        9: 2161:        if (args.getBuffLeft() != 0) {
    #####: 2162:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2163:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2164:          }
        -: 2165:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2166:          break;
        -: 2167:        }
        -: 2168:#endif
        -: 2169:        // Call handler function
        9: 2170:        this->EVAC_REMOVE_cmdHandler(
        -: 2171:            opCode,
        -: 2172:            cmdSeq,
        -: 2173:            id
        9: 2174:        );
        -: 2175:
        9: 2176:        break;
        -: 2177:
        -: 2178:      }
        -: 2179:
        -: 2180:      // Handle command EVAC_DUMP
        6: 2181:      case CMD_EVAC_DUMP: {
        -: 2182:        // Deserialize opcode
        -: 2183:        FwOpcodeType opCode;
        6: 2184:        deserStatus = msg.deserialize(opCode);
        6: 2185:        FW_ASSERT (
        -: 2186:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2187:            static_cast<AssertArg>(deserStatus)
        -: 2188:        );
        -: 2189:
        -: 2190:        // Deserialize command sequence
        -: 2191:        U32 cmdSeq;
        6: 2192:        deserStatus = msg.deserialize(cmdSeq);
        6: 2193:        FW_ASSERT (
        -: 2194:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2195:            static_cast<AssertArg>(deserStatus)
        -: 2196:        );
        -: 2197:
        -: 2198:        // Deserialize command argument buffer
       12: 2199:        Fw::CmdArgBuffer args;
        6: 2200:        deserStatus = msg.deserialize(args);
        6: 2201:        FW_ASSERT (
        -: 2202:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2203:            static_cast<AssertArg>(deserStatus)
        -: 2204:        );
        -: 2205:
        -: 2206:        // Reset buffer
        6: 2207:        args.resetDeser();
        -: 2208:
        -: 2209:        // Make sure there was no data left over.
        -: 2210:        // That means the argument buffer size was incorrect.
        -: 2211:#if FW_CMD_CHECK_RESIDUAL
        6: 2212:        if (args.getBuffLeft() != 0) {
    #####: 2213:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2214:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2215:          }
        -: 2216:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2217:          break;
        -: 2218:        }
        -: 2219:#endif
        -: 2220:        // Call handler function
        6: 2221:        this->EVAC_DUMP_cmdHandler(opCode, cmdSeq);
        -: 2222:
        6: 2223:        break;
        -: 2224:
        -: 2225:      }
        -: 2226:
    #####: 2227:      default:
    #####: 2228:        return MSG_DISPATCH_ERROR;
        -: 2229:
        -: 2230:    }
        -: 2231:
       57: 2232:    return MSG_DISPATCH_OK;
        -: 2233:
        -: 2234:  }
        -: 2235:
        9: 2236:} // end namespace App
