        -:    0:Source:/home/jonathan/Documents/mse/tm/FlightSoftware/FPrime/05_FS/App/build-fprime-automatic-native-ut/App/EventAction/EventActionComponentAc.cpp
        -:    0:Programs:85
        -:    1:// ======================================================================
        -:    2:// \title  EventActionComponentAc.cpp
        -:    3:// \author Auto-generated
        -:    4:// \brief  cpp file for EventAction component base class
        -:    5://
        -:    6:// \copyright
        -:    7:// Copyright 2009-2015, by the California Institute of Technology.
        -:    8:// ALL RIGHTS RESERVED.  United States Government Sponsorship
        -:    9:// acknowledged.
        -:   10://
        -:   11:// ======================================================================
        -:   12:
        -:   13:#include <stdio.h>
        -:   14:#include <FpConfig.hpp>
        -:   15:#include <App/EventAction/EventActionComponentAc.hpp>
        -:   16:#include <Fw/Types/Assert.hpp>
        -:   17:#if FW_ENABLE_TEXT_LOGGING
        -:   18:#include <Fw/Types/EightyCharString.hpp>
        -:   19:#endif
        -:   20:
        -:   21:
        -:   22:namespace App {
        -:   23:
        -:   24:  // ----------------------------------------------------------------------
        -:   25:  // Anonymous namespace to prevent name collisions
        -:   26:  // ----------------------------------------------------------------------
        -:   27:
        -:   28:  namespace {
        -:   29:
        -:   30:    typedef enum {
        -:   31:      EVENTACTION_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
        -:   32:      SEQRESP_CMDRESPONSE,
        -:   33:      LOGRECV_LOG,
        -:   34:      CMD_EVAC_ADD,
        -:   35:      CMD_EVAC_REMOVE,
        -:   36:      CMD_EVAC_DUMP
        -:   37:    } MsgTypeEnum;
        -:   38:
        -:   39:    // Get the max size by doing a union of the input port serialization sizes.
        -:   40:
        -:   41:    typedef union {
        -:   42:      BYTE port1[Fw::InputCmdResponsePort::SERIALIZED_SIZE];
        -:   43:      BYTE port2[Fw::InputLogPort::SERIALIZED_SIZE];
        -:   44:      BYTE cmdPort[Fw::InputCmdPort::SERIALIZED_SIZE];
        -:   45:    } BuffUnion;
        -:   46:
        -:   47:    // Define a message buffer class large enough to handle all the
        -:   48:    // asynchronous inputs to the component
        -:   49:
     1846:   50:    class ComponentIpcSerializableBuffer :
        -:   51:      public Fw::SerializeBufferBase
        -:   52:    {
        -:   53:
        -:   54:      public:
        -:   55:
        -:   56:        enum {
        -:   57:          // Max. message size = size of data + message id + port
        -:   58:          SERIALIZATION_SIZE =
        -:   59:            sizeof(BuffUnion) +
        -:   60:            sizeof(NATIVE_INT_TYPE) +
        -:   61:            sizeof(NATIVE_INT_TYPE)
        -:   62:        };
        -:   63:
     3694:   64:        NATIVE_UINT_TYPE getBuffCapacity(void) const {
     3694:   65:          return sizeof(m_buff);
        -:   66:        }
        -:   67:
    23536:   68:        U8* getBuffAddr(void) {
    23536:   69:          return m_buff;
        -:   70:        }
        -:   71:
      462:   72:        const U8* getBuffAddr(void) const {
      462:   73:          return m_buff;
        -:   74:        }
        -:   75:
        -:   76:      private:
        -:   77:        // Should be the max of all the input ports serialized sizes...
        -:   78:        U8 m_buff[SERIALIZATION_SIZE];
        -:   79:
        -:   80:    };
        -:   81:
        -:   82:  }
        -:   83:
        -:   84:  // ----------------------------------------------------------------------
        -:   85:  // Getters for numbers of input ports
        -:   86:  // ----------------------------------------------------------------------
        -:   87:
      286:   88:  Fw::InputCmdPort *EventActionComponentBase ::
        -:   89:    get_cmdDisp_InputPort(NATIVE_INT_TYPE portNum)
        -:   90:  {
      286:   91:    FW_ASSERT(portNum < this->getNum_cmdDisp_InputPorts(),static_cast<AssertArg>(portNum));
      286:   92:    return &this->m_cmdDisp_InputPort[portNum];
        -:   93:  }
        -:   94:
      286:   95:  Fw::InputCmdResponsePort *EventActionComponentBase ::
        -:   96:    get_seqResp_InputPort(NATIVE_INT_TYPE portNum)
        -:   97:  {
      286:   98:    FW_ASSERT(portNum < this->getNum_seqResp_InputPorts(),static_cast<AssertArg>(portNum));
      286:   99:    return &this->m_seqResp_InputPort[portNum];
        -:  100:  }
        -:  101:
      286:  102:  Fw::InputLogPort *EventActionComponentBase ::
        -:  103:    get_logRecv_InputPort(NATIVE_INT_TYPE portNum)
        -:  104:  {
      286:  105:    FW_ASSERT(portNum < this->getNum_logRecv_InputPorts(),static_cast<AssertArg>(portNum));
      286:  106:    return &this->m_logRecv_InputPort[portNum];
        -:  107:  }
        -:  108:
        -:  109:  // ----------------------------------------------------------------------
        -:  110:  // Typed connectors for output ports
        -:  111:  // ----------------------------------------------------------------------
        -:  112:
      286:  113:  void EventActionComponentBase ::
        -:  114:    set_cmdRegOut_OutputPort(
        -:  115:        NATIVE_INT_TYPE portNum,
        -:  116:        Fw::InputCmdRegPort* port
        -:  117:    )
        -:  118:  {
      286:  119:    FW_ASSERT(portNum < this->getNum_cmdRegOut_OutputPorts(),static_cast<AssertArg>(portNum));
      286:  120:    this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
      286:  121:  }
        -:  122:
      286:  123:  void EventActionComponentBase ::
        -:  124:    set_cmdResponseOut_OutputPort(
        -:  125:        NATIVE_INT_TYPE portNum,
        -:  126:        Fw::InputCmdResponsePort* port
        -:  127:    )
        -:  128:  {
      286:  129:    FW_ASSERT(portNum < this->getNum_cmdResponseOut_OutputPorts(),static_cast<AssertArg>(portNum));
      286:  130:    this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
      286:  131:  }
        -:  132:
      286:  133:  void EventActionComponentBase ::
        -:  134:    set_eventOut_OutputPort(
        -:  135:        NATIVE_INT_TYPE portNum,
        -:  136:        Fw::InputLogPort* port
        -:  137:    )
        -:  138:  {
      286:  139:    FW_ASSERT(portNum < this->getNum_eventOut_OutputPorts(),static_cast<AssertArg>(portNum));
      286:  140:    this->m_eventOut_OutputPort[portNum].addCallPort(port);
      286:  141:  }
        -:  142:
        -:  143:#if FW_ENABLE_TEXT_LOGGING == 1
      286:  144:  void EventActionComponentBase ::
        -:  145:    set_txtEventOut_OutputPort(
        -:  146:        NATIVE_INT_TYPE portNum,
        -:  147:        Fw::InputLogTextPort* port
        -:  148:    )
        -:  149:  {
      286:  150:    FW_ASSERT(portNum < this->getNum_txtEventOut_OutputPorts(),static_cast<AssertArg>(portNum));
      286:  151:    this->m_txtEventOut_OutputPort[portNum].addCallPort(port);
      286:  152:  }
        -:  153:#endif
        -:  154:
      286:  155:  void EventActionComponentBase ::
        -:  156:    set_tlmOut_OutputPort(
        -:  157:        NATIVE_INT_TYPE portNum,
        -:  158:        Fw::InputTlmPort* port
        -:  159:    )
        -:  160:  {
      286:  161:    FW_ASSERT(portNum < this->getNum_tlmOut_OutputPorts(),static_cast<AssertArg>(portNum));
      286:  162:    this->m_tlmOut_OutputPort[portNum].addCallPort(port);
      286:  163:  }
        -:  164:
      286:  165:  void EventActionComponentBase ::
        -:  166:    set_seqRun_OutputPort(
        -:  167:        NATIVE_INT_TYPE portNum,
        -:  168:        Svc::InputCmdSeqInPort* port
        -:  169:    )
        -:  170:  {
      286:  171:    FW_ASSERT(portNum < this->getNum_seqRun_OutputPorts(),static_cast<AssertArg>(portNum));
      286:  172:    this->m_seqRun_OutputPort[portNum].addCallPort(port);
      286:  173:  }
        -:  174:
      286:  175:  void EventActionComponentBase ::
        -:  176:    set_Time_OutputPort(
        -:  177:        NATIVE_INT_TYPE portNum,
        -:  178:        Fw::InputTimePort* port
        -:  179:    )
        -:  180:  {
      286:  181:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
      286:  182:    this->m_Time_OutputPort[portNum].addCallPort(port);
      286:  183:  }
        -:  184:
        -:  185:  // ----------------------------------------------------------------------
        -:  186:  // Serialization connectors for output ports
        -:  187:  // ----------------------------------------------------------------------
        -:  188:
        -:  189:#if FW_PORT_SERIALIZATION
        -:  190:
    #####:  191:  void EventActionComponentBase ::
        -:  192:    set_cmdRegOut_OutputPort(
        -:  193:        NATIVE_INT_TYPE portNum,
        -:  194:        Fw::InputSerializePort *port
        -:  195:    )
        -:  196:  {
    #####:  197:    FW_ASSERT(portNum < this->getNum_cmdRegOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  198:    return this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
        -:  199:  }
        -:  200:
    #####:  201:  void EventActionComponentBase ::
        -:  202:    set_cmdResponseOut_OutputPort(
        -:  203:        NATIVE_INT_TYPE portNum,
        -:  204:        Fw::InputSerializePort *port
        -:  205:    )
        -:  206:  {
    #####:  207:    FW_ASSERT(portNum < this->getNum_cmdResponseOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  208:    return this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
        -:  209:  }
        -:  210:
    #####:  211:  void EventActionComponentBase ::
        -:  212:    set_eventOut_OutputPort(
        -:  213:        NATIVE_INT_TYPE portNum,
        -:  214:        Fw::InputSerializePort *port
        -:  215:    )
        -:  216:  {
    #####:  217:    FW_ASSERT(portNum < this->getNum_eventOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  218:    return this->m_eventOut_OutputPort[portNum].registerSerialPort(port);
        -:  219:  }
        -:  220:
        -:  221:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  222:  void EventActionComponentBase ::
        -:  223:    set_txtEventOut_OutputPort(
        -:  224:        NATIVE_INT_TYPE portNum,
        -:  225:        Fw::InputSerializePort *port
        -:  226:    )
        -:  227:  {
    #####:  228:    FW_ASSERT(portNum < this->getNum_txtEventOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  229:    return this->m_txtEventOut_OutputPort[portNum].registerSerialPort(port);
        -:  230:  }
        -:  231:#endif
        -:  232:
    #####:  233:  void EventActionComponentBase ::
        -:  234:    set_tlmOut_OutputPort(
        -:  235:        NATIVE_INT_TYPE portNum,
        -:  236:        Fw::InputSerializePort *port
        -:  237:    )
        -:  238:  {
    #####:  239:    FW_ASSERT(portNum < this->getNum_tlmOut_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  240:    return this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
        -:  241:  }
        -:  242:
    #####:  243:  void EventActionComponentBase ::
        -:  244:    set_seqRun_OutputPort(
        -:  245:        NATIVE_INT_TYPE portNum,
        -:  246:        Fw::InputSerializePort *port
        -:  247:    )
        -:  248:  {
    #####:  249:    FW_ASSERT(portNum < this->getNum_seqRun_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  250:    return this->m_seqRun_OutputPort[portNum].registerSerialPort(port);
        -:  251:  }
        -:  252:
    #####:  253:  void EventActionComponentBase ::
        -:  254:    set_Time_OutputPort(
        -:  255:        NATIVE_INT_TYPE portNum,
        -:  256:        Fw::InputSerializePort *port
        -:  257:    )
        -:  258:  {
    #####:  259:    FW_ASSERT(portNum < this->getNum_Time_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  260:    return this->m_Time_OutputPort[portNum].registerSerialPort(port);
        -:  261:  }
        -:  262:
        -:  263:#endif
        -:  264:
        -:  265:  // ----------------------------------------------------------------------
        -:  266:  // Command registration
        -:  267:  // ----------------------------------------------------------------------
        -:  268:
    #####:  269:  void EventActionComponentBase ::
        -:  270:    regCommands(void)
        -:  271:  {
    #####:  272:    FW_ASSERT(this->m_cmdRegOut_OutputPort[0].isConnected());
    #####:  273:    this->m_cmdRegOut_OutputPort[0].invoke(
        -:  274:        this->getIdBase() + OPCODE_EVAC_ADD
        -:  275:    );
    #####:  276:    this->m_cmdRegOut_OutputPort[0].invoke(
    #####:  277:        this->getIdBase() + OPCODE_EVAC_REMOVE
        -:  278:    );
    #####:  279:    this->m_cmdRegOut_OutputPort[0].invoke(
    #####:  280:        this->getIdBase() + OPCODE_EVAC_DUMP
        -:  281:    );
    #####:  282:  }
        -:  283:
        -:  284:  // ----------------------------------------------------------------------
        -:  285:  // Component construction, initialization, and destruction
        -:  286:  // ----------------------------------------------------------------------
        -:  287:
      286:  288:    EventActionComponentBase :: EventActionComponentBase(const char* compName) :
      286:  289:        Fw::ActiveComponentBase(compName) {
        -:  290:
        -:  291:
        -:  292:
      286:  293:  }
        -:  294:
      286:  295:  void EventActionComponentBase ::
        -:  296:    init(
        -:  297:        NATIVE_INT_TYPE queueDepth,
        -:  298:        NATIVE_INT_TYPE instance
        -:  299:    )
        -:  300:  {
        -:  301:
        -:  302:    // Initialize base class
      286:  303:    Fw::ActiveComponentBase::init(instance);
        -:  304:
        -:  305:    // Connect input port cmdDisp
      286:  306:    for (
      286:  307:        NATIVE_INT_TYPE port = 0;
      572:  308:        port < this->getNum_cmdDisp_InputPorts();
        -:  309:        port++
        -:  310:    ) {
        -:  311:
      286:  312:      this->m_cmdDisp_InputPort[port].init();
      286:  313:      this->m_cmdDisp_InputPort[port].addCallComp(
        -:  314:          this,
        -:  315:          m_p_cmdDisp_in
        -:  316:      );
      286:  317:      this->m_cmdDisp_InputPort[port].setPortNum(port);
        -:  318:
        -:  319:#if FW_OBJECT_NAMES == 1
        -:  320:      char portName[120];
      286:  321:      (void) snprintf(
        -:  322:          portName,
        -:  323:          sizeof(portName),
        -:  324:          "%s_cmdDisp_InputPort[%d]",
        -:  325:          this->m_objName,
        -:  326:          port
        -:  327:      );
      286:  328:      this->m_cmdDisp_InputPort[port].setObjName(portName);
        -:  329:#endif
        -:  330:
        -:  331:    }
        -:  332:
        -:  333:    // Connect input port seqResp
      286:  334:    for (
      286:  335:        NATIVE_INT_TYPE port = 0;
      572:  336:        port < this->getNum_seqResp_InputPorts();
        -:  337:        port++
        -:  338:    ) {
        -:  339:
      286:  340:      this->m_seqResp_InputPort[port].init();
      286:  341:      this->m_seqResp_InputPort[port].addCallComp(
        -:  342:          this,
        -:  343:          m_p_seqResp_in
        -:  344:      );
      286:  345:      this->m_seqResp_InputPort[port].setPortNum(port);
        -:  346:
        -:  347:#if FW_OBJECT_NAMES == 1
        -:  348:      char portName[120];
      286:  349:      (void) snprintf(
        -:  350:          portName,
        -:  351:          sizeof(portName),
        -:  352:          "%s_seqResp_InputPort[%d]",
        -:  353:          this->m_objName,
        -:  354:          port
        -:  355:      );
      286:  356:      this->m_seqResp_InputPort[port].setObjName(portName);
        -:  357:#endif
        -:  358:
        -:  359:    }
        -:  360:
        -:  361:    // Connect input port logRecv
      286:  362:    for (
      286:  363:        NATIVE_INT_TYPE port = 0;
      572:  364:        port < this->getNum_logRecv_InputPorts();
        -:  365:        port++
        -:  366:    ) {
        -:  367:
      286:  368:      this->m_logRecv_InputPort[port].init();
      286:  369:      this->m_logRecv_InputPort[port].addCallComp(
        -:  370:          this,
        -:  371:          m_p_logRecv_in
        -:  372:      );
      286:  373:      this->m_logRecv_InputPort[port].setPortNum(port);
        -:  374:
        -:  375:#if FW_OBJECT_NAMES == 1
        -:  376:      char portName[120];
      286:  377:      (void) snprintf(
        -:  378:          portName,
        -:  379:          sizeof(portName),
        -:  380:          "%s_logRecv_InputPort[%d]",
        -:  381:          this->m_objName,
        -:  382:          port
        -:  383:      );
      286:  384:      this->m_logRecv_InputPort[port].setObjName(portName);
        -:  385:#endif
        -:  386:
        -:  387:    }
        -:  388:
        -:  389:    // Initialize output port cmdRegOut
      286:  390:    for (
      286:  391:        NATIVE_INT_TYPE port = 0;
      572:  392:        port < this->getNum_cmdRegOut_OutputPorts();
        -:  393:        port++
        -:  394:    ) {
      286:  395:      this->m_cmdRegOut_OutputPort[port].init();
        -:  396:
        -:  397:#if FW_OBJECT_NAMES == 1
        -:  398:      char portName[120];
      286:  399:      (void) snprintf(
        -:  400:          portName,
        -:  401:          sizeof(portName),
        -:  402:          "%s_cmdRegOut_OutputPort[%d]",
        -:  403:          this->m_objName,
        -:  404:          port
        -:  405:      );
      286:  406:      this->m_cmdRegOut_OutputPort[port].setObjName(portName);
        -:  407:#endif
        -:  408:
        -:  409:    }
        -:  410:
        -:  411:    // Initialize output port cmdResponseOut
      286:  412:    for (
      286:  413:        NATIVE_INT_TYPE port = 0;
      572:  414:        port < this->getNum_cmdResponseOut_OutputPorts();
        -:  415:        port++
        -:  416:    ) {
      286:  417:      this->m_cmdResponseOut_OutputPort[port].init();
        -:  418:
        -:  419:#if FW_OBJECT_NAMES == 1
        -:  420:      char portName[120];
      286:  421:      (void) snprintf(
        -:  422:          portName,
        -:  423:          sizeof(portName),
        -:  424:          "%s_cmdResponseOut_OutputPort[%d]",
        -:  425:          this->m_objName,
        -:  426:          port
        -:  427:      );
      286:  428:      this->m_cmdResponseOut_OutputPort[port].setObjName(portName);
        -:  429:#endif
        -:  430:
        -:  431:    }
        -:  432:
        -:  433:    // Initialize output port eventOut
      286:  434:    for (
      286:  435:        NATIVE_INT_TYPE port = 0;
      572:  436:        port < this->getNum_eventOut_OutputPorts();
        -:  437:        port++
        -:  438:    ) {
      286:  439:      this->m_eventOut_OutputPort[port].init();
        -:  440:
        -:  441:#if FW_OBJECT_NAMES == 1
        -:  442:      char portName[120];
      286:  443:      (void) snprintf(
        -:  444:          portName,
        -:  445:          sizeof(portName),
        -:  446:          "%s_eventOut_OutputPort[%d]",
        -:  447:          this->m_objName,
        -:  448:          port
        -:  449:      );
      286:  450:      this->m_eventOut_OutputPort[port].setObjName(portName);
        -:  451:#endif
        -:  452:
        -:  453:    }
        -:  454:
        -:  455:    // Initialize output port txtEventOut
        -:  456:#if FW_ENABLE_TEXT_LOGGING == 1
      286:  457:    for (
      286:  458:        NATIVE_INT_TYPE port = 0;
      572:  459:        port < this->getNum_txtEventOut_OutputPorts();
        -:  460:        port++
        -:  461:    ) {
      286:  462:      this->m_txtEventOut_OutputPort[port].init();
        -:  463:
        -:  464:#if FW_OBJECT_NAMES == 1
        -:  465:      char portName[120];
      286:  466:      (void) snprintf(
        -:  467:          portName,
        -:  468:          sizeof(portName),
        -:  469:          "%s_txtEventOut_OutputPort[%d]",
        -:  470:          this->m_objName,
        -:  471:          port
        -:  472:      );
      286:  473:      this->m_txtEventOut_OutputPort[port].setObjName(portName);
        -:  474:#endif
        -:  475:
        -:  476:    }
        -:  477:#endif
        -:  478:
        -:  479:    // Initialize output port tlmOut
      286:  480:    for (
      286:  481:        NATIVE_INT_TYPE port = 0;
      572:  482:        port < this->getNum_tlmOut_OutputPorts();
        -:  483:        port++
        -:  484:    ) {
      286:  485:      this->m_tlmOut_OutputPort[port].init();
        -:  486:
        -:  487:#if FW_OBJECT_NAMES == 1
        -:  488:      char portName[120];
      286:  489:      (void) snprintf(
        -:  490:          portName,
        -:  491:          sizeof(portName),
        -:  492:          "%s_tlmOut_OutputPort[%d]",
        -:  493:          this->m_objName,
        -:  494:          port
        -:  495:      );
      286:  496:      this->m_tlmOut_OutputPort[port].setObjName(portName);
        -:  497:#endif
        -:  498:
        -:  499:    }
        -:  500:
        -:  501:    // Initialize output port seqRun
      286:  502:    for (
      286:  503:        NATIVE_INT_TYPE port = 0;
      572:  504:        port < this->getNum_seqRun_OutputPorts();
        -:  505:        port++
        -:  506:    ) {
      286:  507:      this->m_seqRun_OutputPort[port].init();
        -:  508:
        -:  509:#if FW_OBJECT_NAMES == 1
        -:  510:      char portName[120];
      286:  511:      (void) snprintf(
        -:  512:          portName,
        -:  513:          sizeof(portName),
        -:  514:          "%s_seqRun_OutputPort[%d]",
        -:  515:          this->m_objName,
        -:  516:          port
        -:  517:      );
      286:  518:      this->m_seqRun_OutputPort[port].setObjName(portName);
        -:  519:#endif
        -:  520:
        -:  521:    }
        -:  522:
        -:  523:    // Initialize output port Time
      286:  524:    for (
      286:  525:        NATIVE_INT_TYPE port = 0;
      572:  526:        port < this->getNum_Time_OutputPorts();
        -:  527:        port++
        -:  528:    ) {
      286:  529:      this->m_Time_OutputPort[port].init();
        -:  530:
        -:  531:#if FW_OBJECT_NAMES == 1
        -:  532:      char portName[120];
      286:  533:      (void) snprintf(
        -:  534:          portName,
        -:  535:          sizeof(portName),
        -:  536:          "%s_Time_OutputPort[%d]",
        -:  537:          this->m_objName,
        -:  538:          port
        -:  539:      );
      286:  540:      this->m_Time_OutputPort[port].setObjName(portName);
        -:  541:#endif
        -:  542:
        -:  543:    }
        -:  544:
        -:  545:    Os::Queue::QueueStatus qStat =
      286:  546:    this->createQueue(
        -:  547:        queueDepth,
        -:  548:        ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
      286:  549:    );
      286:  550:    FW_ASSERT(
        -:  551:        Os::Queue::QUEUE_OK == qStat,
        -:  552:        static_cast<AssertArg>(qStat)
        -:  553:    );
        -:  554:
      286:  555:  }
        -:  556:
      286:  557:  EventActionComponentBase::
      286:  558:    ~EventActionComponentBase() {
        -:  559:
      286:  560:  }
        -:  561:
        -:  562:  // ----------------------------------------------------------------------
        -:  563:  // Invocation functions for output ports
        -:  564:  // ----------------------------------------------------------------------
        -:  565:
    #####:  566:  void EventActionComponentBase ::
        -:  567:    seqRun_out(
        -:  568:        NATIVE_INT_TYPE portNum,
        -:  569:        Fw::EightyCharString &filename
        -:  570:    )
        -:  571:  {
    #####:  572:    FW_ASSERT(portNum < this->getNum_seqRun_OutputPorts(),static_cast<AssertArg>(portNum));
    #####:  573:    this->m_seqRun_OutputPort[portNum].invoke(filename);
    #####:  574:  }
        -:  575:
        -:  576:  // ----------------------------------------------------------------------
        -:  577:  // Getters for numbers of ports
        -:  578:  // ----------------------------------------------------------------------
        -:  579:
      858:  580:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  581:    getNum_cmdDisp_InputPorts(void)
        -:  582:  {
      858:  583:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  584:        this->m_cmdDisp_InputPort
        -:  585:    );
        -:  586:  }
        -:  587:
      858:  588:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  589:    getNum_cmdRegOut_OutputPorts(void)
        -:  590:  {
      858:  591:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  592:        this->m_cmdRegOut_OutputPort
        -:  593:    );
        -:  594:  }
        -:  595:
      858:  596:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  597:    getNum_cmdResponseOut_OutputPorts(void)
        -:  598:  {
      858:  599:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  600:        this->m_cmdResponseOut_OutputPort
        -:  601:    );
        -:  602:  }
        -:  603:
      858:  604:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  605:    getNum_eventOut_OutputPorts(void)
        -:  606:  {
      858:  607:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  608:        this->m_eventOut_OutputPort
        -:  609:    );
        -:  610:  }
        -:  611:
        -:  612:#if FW_ENABLE_TEXT_LOGGING == 1
      858:  613:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  614:    getNum_txtEventOut_OutputPorts(void)
        -:  615:  {
      858:  616:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  617:        this->m_txtEventOut_OutputPort
        -:  618:    );
        -:  619:  }
        -:  620:#endif
        -:  621:
      858:  622:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  623:    getNum_tlmOut_OutputPorts(void)
        -:  624:  {
      858:  625:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  626:        this->m_tlmOut_OutputPort
        -:  627:    );
        -:  628:  }
        -:  629:
      858:  630:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  631:    getNum_seqRun_OutputPorts(void)
        -:  632:  {
      858:  633:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  634:        this->m_seqRun_OutputPort
        -:  635:    );
        -:  636:  }
        -:  637:
      858:  638:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  639:    getNum_seqResp_InputPorts(void)
        -:  640:  {
      858:  641:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  642:        this->m_seqResp_InputPort
        -:  643:    );
        -:  644:  }
        -:  645:
      858:  646:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  647:    getNum_logRecv_InputPorts(void)
        -:  648:  {
      858:  649:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  650:        this->m_logRecv_InputPort
        -:  651:    );
        -:  652:  }
        -:  653:
      858:  654:  NATIVE_INT_TYPE EventActionComponentBase ::
        -:  655:    getNum_Time_OutputPorts(void)
        -:  656:  {
      858:  657:    return (NATIVE_INT_TYPE) FW_NUM_ARRAY_ELEMENTS(
        -:  658:        this->m_Time_OutputPort
        -:  659:    );
        -:  660:  }
        -:  661:
        -:  662:  // ----------------------------------------------------------------------
        -:  663:  // Port connection status queries
        -:  664:  // ----------------------------------------------------------------------
        -:  665:
    #####:  666:  bool EventActionComponentBase ::
        -:  667:    isConnected_cmdRegOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  668:  {
    #####:  669:     FW_ASSERT(
        -:  670:        portNum < this->getNum_cmdRegOut_OutputPorts(),
        -:  671:        static_cast<AssertArg>(portNum)
        -:  672:     );
    #####:  673:     return this->m_cmdRegOut_OutputPort[portNum].isConnected();
        -:  674:  }
        -:  675:
    #####:  676:  bool EventActionComponentBase ::
        -:  677:    isConnected_cmdResponseOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  678:  {
    #####:  679:     FW_ASSERT(
        -:  680:        portNum < this->getNum_cmdResponseOut_OutputPorts(),
        -:  681:        static_cast<AssertArg>(portNum)
        -:  682:     );
    #####:  683:     return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
        -:  684:  }
        -:  685:
    #####:  686:  bool EventActionComponentBase ::
        -:  687:    isConnected_eventOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  688:  {
    #####:  689:     FW_ASSERT(
        -:  690:        portNum < this->getNum_eventOut_OutputPorts(),
        -:  691:        static_cast<AssertArg>(portNum)
        -:  692:     );
    #####:  693:     return this->m_eventOut_OutputPort[portNum].isConnected();
        -:  694:  }
        -:  695:
        -:  696:#if FW_ENABLE_TEXT_LOGGING == 1
    #####:  697:  bool EventActionComponentBase ::
        -:  698:    isConnected_txtEventOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  699:  {
    #####:  700:     FW_ASSERT(
        -:  701:        portNum < this->getNum_txtEventOut_OutputPorts(),
        -:  702:        static_cast<AssertArg>(portNum)
        -:  703:     );
    #####:  704:     return this->m_txtEventOut_OutputPort[portNum].isConnected();
        -:  705:  }
        -:  706:#endif
        -:  707:
    #####:  708:  bool EventActionComponentBase ::
        -:  709:    isConnected_tlmOut_OutputPort(NATIVE_INT_TYPE portNum)
        -:  710:  {
    #####:  711:     FW_ASSERT(
        -:  712:        portNum < this->getNum_tlmOut_OutputPorts(),
        -:  713:        static_cast<AssertArg>(portNum)
        -:  714:     );
    #####:  715:     return this->m_tlmOut_OutputPort[portNum].isConnected();
        -:  716:  }
        -:  717:
    #####:  718:  bool EventActionComponentBase ::
        -:  719:    isConnected_seqRun_OutputPort(NATIVE_INT_TYPE portNum)
        -:  720:  {
    #####:  721:     FW_ASSERT(
        -:  722:        portNum < this->getNum_seqRun_OutputPorts(),
        -:  723:        static_cast<AssertArg>(portNum)
        -:  724:     );
    #####:  725:     return this->m_seqRun_OutputPort[portNum].isConnected();
        -:  726:  }
        -:  727:
    #####:  728:  bool EventActionComponentBase ::
        -:  729:    isConnected_Time_OutputPort(NATIVE_INT_TYPE portNum)
        -:  730:  {
    #####:  731:     FW_ASSERT(
        -:  732:        portNum < this->getNum_Time_OutputPorts(),
        -:  733:        static_cast<AssertArg>(portNum)
        -:  734:     );
    #####:  735:     return this->m_Time_OutputPort[portNum].isConnected();
        -:  736:  }
        -:  737:
        -:  738:  // ----------------------------------------------------------------------
        -:  739:  // Calls for messages received on command input ports
        -:  740:  // ----------------------------------------------------------------------
        -:  741:
      462:  742:  void EventActionComponentBase ::
        -:  743:    m_p_cmdDisp_in(
        -:  744:        Fw::PassiveComponentBase* callComp,
        -:  745:        NATIVE_INT_TYPE portNum,
        -:  746:        FwOpcodeType opCode,
        -:  747:        U32 cmdSeq,
        -:  748:        Fw::CmdArgBuffer &args
        -:  749:    )
        -:  750:  {
        -:  751:
        -:  752:    // Select base class function based on opcode
      462:  753:    FW_ASSERT(callComp);
      462:  754:    EventActionComponentBase* compPtr =
        -:  755:      (EventActionComponentBase*) callComp;
        -:  756:
      462:  757:    const U32 idBase = callComp->getIdBase();
      462:  758:    FW_ASSERT(opCode >= idBase, opCode, idBase);
      462:  759:    switch (opCode - idBase) {
        -:  760:
      287:  761:      case OPCODE_EVAC_ADD: /*!< Add sequence for an event id */
      287:  762:        compPtr->EVAC_ADD_cmdHandlerBase(
        -:  763:            opCode,
        -:  764:            cmdSeq,
        -:  765:            args
        -:  766:        );
      287:  767:        break;
        -:  768:
      117:  769:      case OPCODE_EVAC_REMOVE: /*!< Remove sequence for a specific envent id */
      117:  770:        compPtr->EVAC_REMOVE_cmdHandlerBase(
        -:  771:            opCode,
        -:  772:            cmdSeq,
        -:  773:            args
        -:  774:        );
      117:  775:        break;
        -:  776:
       58:  777:      case OPCODE_EVAC_DUMP: /*!< Dump event-sequence list */
       58:  778:        compPtr->EVAC_DUMP_cmdHandlerBase(
        -:  779:            opCode,
        -:  780:            cmdSeq,
        -:  781:            args
        -:  782:        );
       58:  783:        break;
        -:  784:
    #####:  785:      default: {
    #####:  786:        compPtr->cmdResponse_out(
        -:  787:            opCode,cmdSeq,
        -:  788:            Fw::COMMAND_INVALID_OPCODE
        -:  789:        );
    #####:  790:        break;
        -:  791:      }
        -:  792:
        -:  793:    }
        -:  794:
      462:  795:  }
        -:  796:
      461:  797:  void EventActionComponentBase ::
        -:  798:    cmdResponse_out(
        -:  799:        FwOpcodeType opCode,
        -:  800:        U32 cmdSeq,
        -:  801:        Fw::CommandResponse response
        -:  802:    )
        -:  803:  {
      461:  804:    FW_ASSERT(this->m_cmdResponseOut_OutputPort[0].isConnected());
      461:  805:    this->m_cmdResponseOut_OutputPort[0].invoke(opCode,cmdSeq,response);
      461:  806:  }
        -:  807:
        -:  808:  // ----------------------------------------------------------------------
        -:  809:  // Base class command functions
        -:  810:  // ----------------------------------------------------------------------
        -:  811:
      287:  812:  void EventActionComponentBase ::
        -:  813:    EVAC_ADD_cmdHandlerBase(
        -:  814:        FwOpcodeType opCode,
        -:  815:        U32 cmdSeq,
        -:  816:        Fw::CmdArgBuffer &args
        -:  817:    )
        -:  818:  {
        -:  819:
        -:  820:    // Call pre-message hook
      287:  821:    this->EVAC_ADD_preMsgHook(opCode,cmdSeq);
        -:  822:
        -:  823:    // Defer deserializing arguments to the message dispatcher
        -:  824:    // to avoid deserializing and reserializing just for IPC
      574:  825:    ComponentIpcSerializableBuffer msg;
      287:  826:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  827:
        -:  828:    // Serialize for IPC
      287:  829:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_EVAC_ADD);
      287:  830:    FW_ASSERT (
        -:  831:        _status == Fw::FW_SERIALIZE_OK,
        -:  832:        static_cast<AssertArg>(_status)
        -:  833:        );
        -:  834:
        -:  835:    // Fake port number to make message dequeue work
      287:  836:    NATIVE_INT_TYPE port = 0;
      287:  837:    _status = msg.serialize(port);
      287:  838:    FW_ASSERT (
        -:  839:        _status == Fw::FW_SERIALIZE_OK,
        -:  840:        static_cast<AssertArg>(_status)
        -:  841:    );
        -:  842:
      287:  843:    _status = msg.serialize(opCode);
      287:  844:    FW_ASSERT (
        -:  845:        _status == Fw::FW_SERIALIZE_OK,
        -:  846:        static_cast<AssertArg>(_status)
        -:  847:    );
        -:  848:
      287:  849:    _status = msg.serialize(cmdSeq);
      287:  850:    FW_ASSERT (
        -:  851:        _status == Fw::FW_SERIALIZE_OK,
        -:  852:        static_cast<AssertArg>(_status)
        -:  853:    );
        -:  854:
      287:  855:    _status = msg.serialize(args);
      287:  856:    FW_ASSERT (
        -:  857:        _status == Fw::FW_SERIALIZE_OK,
        -:  858:        static_cast<AssertArg>(_status)
        -:  859:    );
        -:  860:
        -:  861:    // send message
      287:  862:    Os::Queue::QueueBlocking _block =
        -:  863:      Os::Queue::QUEUE_NONBLOCKING;
        -:  864:    Os::Queue::QueueStatus qStatus =
      287:  865:      this->m_queue.send(msg, 0,_block);
      287:  866:    FW_ASSERT(
        -:  867:        qStatus == Os::Queue::QUEUE_OK,
        -:  868:        static_cast<AssertArg>(qStatus)
        -:  869:    );
        -:  870:
      287:  871:  }
        -:  872:
      287:  873:  void EventActionComponentBase::
        -:  874:    EVAC_ADD_preMsgHook(
        -:  875:        FwOpcodeType opCode,
        -:  876:        U32 cmdSeq
        -:  877:    )
        -:  878:  {
        -:  879:    // Defaults to no-op; can be overridden
      287:  880:  }
        -:  881:
      117:  882:  void EventActionComponentBase ::
        -:  883:    EVAC_REMOVE_cmdHandlerBase(
        -:  884:        FwOpcodeType opCode,
        -:  885:        U32 cmdSeq,
        -:  886:        Fw::CmdArgBuffer &args
        -:  887:    )
        -:  888:  {
        -:  889:
        -:  890:    // Call pre-message hook
      117:  891:    this->EVAC_REMOVE_preMsgHook(opCode,cmdSeq);
        -:  892:
        -:  893:    // Defer deserializing arguments to the message dispatcher
        -:  894:    // to avoid deserializing and reserializing just for IPC
      234:  895:    ComponentIpcSerializableBuffer msg;
      117:  896:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  897:
        -:  898:    // Serialize for IPC
      117:  899:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_EVAC_REMOVE);
      117:  900:    FW_ASSERT (
        -:  901:        _status == Fw::FW_SERIALIZE_OK,
        -:  902:        static_cast<AssertArg>(_status)
        -:  903:        );
        -:  904:
        -:  905:    // Fake port number to make message dequeue work
      117:  906:    NATIVE_INT_TYPE port = 0;
      117:  907:    _status = msg.serialize(port);
      117:  908:    FW_ASSERT (
        -:  909:        _status == Fw::FW_SERIALIZE_OK,
        -:  910:        static_cast<AssertArg>(_status)
        -:  911:    );
        -:  912:
      117:  913:    _status = msg.serialize(opCode);
      117:  914:    FW_ASSERT (
        -:  915:        _status == Fw::FW_SERIALIZE_OK,
        -:  916:        static_cast<AssertArg>(_status)
        -:  917:    );
        -:  918:
      117:  919:    _status = msg.serialize(cmdSeq);
      117:  920:    FW_ASSERT (
        -:  921:        _status == Fw::FW_SERIALIZE_OK,
        -:  922:        static_cast<AssertArg>(_status)
        -:  923:    );
        -:  924:
      117:  925:    _status = msg.serialize(args);
      117:  926:    FW_ASSERT (
        -:  927:        _status == Fw::FW_SERIALIZE_OK,
        -:  928:        static_cast<AssertArg>(_status)
        -:  929:    );
        -:  930:
        -:  931:    // send message
      117:  932:    Os::Queue::QueueBlocking _block =
        -:  933:      Os::Queue::QUEUE_NONBLOCKING;
        -:  934:    Os::Queue::QueueStatus qStatus =
      117:  935:      this->m_queue.send(msg, 0,_block);
      117:  936:    FW_ASSERT(
        -:  937:        qStatus == Os::Queue::QUEUE_OK,
        -:  938:        static_cast<AssertArg>(qStatus)
        -:  939:    );
        -:  940:
      117:  941:  }
        -:  942:
      117:  943:  void EventActionComponentBase::
        -:  944:    EVAC_REMOVE_preMsgHook(
        -:  945:        FwOpcodeType opCode,
        -:  946:        U32 cmdSeq
        -:  947:    )
        -:  948:  {
        -:  949:    // Defaults to no-op; can be overridden
      117:  950:  }
        -:  951:
       58:  952:  void EventActionComponentBase ::
        -:  953:    EVAC_DUMP_cmdHandlerBase(
        -:  954:        FwOpcodeType opCode,
        -:  955:        U32 cmdSeq,
        -:  956:        Fw::CmdArgBuffer &args
        -:  957:    )
        -:  958:  {
        -:  959:
        -:  960:    // Call pre-message hook
       58:  961:    this->EVAC_DUMP_preMsgHook(opCode,cmdSeq);
        -:  962:
        -:  963:    // Defer deserializing arguments to the message dispatcher
        -:  964:    // to avoid deserializing and reserializing just for IPC
      116:  965:    ComponentIpcSerializableBuffer msg;
       58:  966:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -:  967:
        -:  968:    // Serialize for IPC
       58:  969:    _status = msg.serialize((NATIVE_INT_TYPE)CMD_EVAC_DUMP);
       58:  970:    FW_ASSERT (
        -:  971:        _status == Fw::FW_SERIALIZE_OK,
        -:  972:        static_cast<AssertArg>(_status)
        -:  973:        );
        -:  974:
        -:  975:    // Fake port number to make message dequeue work
       58:  976:    NATIVE_INT_TYPE port = 0;
       58:  977:    _status = msg.serialize(port);
       58:  978:    FW_ASSERT (
        -:  979:        _status == Fw::FW_SERIALIZE_OK,
        -:  980:        static_cast<AssertArg>(_status)
        -:  981:    );
        -:  982:
       58:  983:    _status = msg.serialize(opCode);
       58:  984:    FW_ASSERT (
        -:  985:        _status == Fw::FW_SERIALIZE_OK,
        -:  986:        static_cast<AssertArg>(_status)
        -:  987:    );
        -:  988:
       58:  989:    _status = msg.serialize(cmdSeq);
       58:  990:    FW_ASSERT (
        -:  991:        _status == Fw::FW_SERIALIZE_OK,
        -:  992:        static_cast<AssertArg>(_status)
        -:  993:    );
        -:  994:
       58:  995:    _status = msg.serialize(args);
       58:  996:    FW_ASSERT (
        -:  997:        _status == Fw::FW_SERIALIZE_OK,
        -:  998:        static_cast<AssertArg>(_status)
        -:  999:    );
        -: 1000:
        -: 1001:    // send message
       58: 1002:    Os::Queue::QueueBlocking _block =
        -: 1003:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1004:    Os::Queue::QueueStatus qStatus =
       58: 1005:      this->m_queue.send(msg, 0,_block);
       58: 1006:    FW_ASSERT(
        -: 1007:        qStatus == Os::Queue::QUEUE_OK,
        -: 1008:        static_cast<AssertArg>(qStatus)
        -: 1009:    );
        -: 1010:
       58: 1011:  }
        -: 1012:
       58: 1013:  void EventActionComponentBase::
        -: 1014:    EVAC_DUMP_preMsgHook(
        -: 1015:        FwOpcodeType opCode,
        -: 1016:        U32 cmdSeq
        -: 1017:    )
        -: 1018:  {
        -: 1019:    // Defaults to no-op; can be overridden
       58: 1020:  }
        -: 1021:
        -: 1022:  // ----------------------------------------------------------------------
        -: 1023:  // Telemetry write functions
        -: 1024:  // ----------------------------------------------------------------------
        -: 1025:
        4: 1026:  void EventActionComponentBase ::
        -: 1027:    tlmWrite_EVAC_CHA(U32 arg)
        -: 1028:  {
        -: 1029:
        4: 1030:    if (this->m_tlmOut_OutputPort[0].isConnected()) {
        8: 1031:      Fw::Time _tlmTime;
        4: 1032:      if (this->m_Time_OutputPort[0].isConnected()) {
        4: 1033:         this->m_Time_OutputPort[0].invoke( _tlmTime);
        -: 1034:      }
        8: 1035:      Fw::TlmBuffer _tlmBuff;
        4: 1036:      Fw::SerializeStatus _stat = _tlmBuff.serialize(arg);
        4: 1037:      FW_ASSERT(
        -: 1038:          _stat == Fw::FW_SERIALIZE_OK,
        -: 1039:          static_cast<AssertArg>(_stat)
        -: 1040:      );
        -: 1041:
        -: 1042:      FwChanIdType _id;
        -: 1043:
        4: 1044:      _id = this->getIdBase() + CHANNELID_EVAC_CHA;
        -: 1045:
        4: 1046:      this->m_tlmOut_OutputPort[0].invoke(
        -: 1047:          _id,
        -: 1048:          _tlmTime,
        -: 1049:          _tlmBuff
        -: 1050:      );
        -: 1051:    }
        -: 1052:
        4: 1053:  }
        -: 1054:
        -: 1055:  // ----------------------------------------------------------------------
        -: 1056:  // Time
        -: 1057:  // ----------------------------------------------------------------------
        -: 1058:
    #####: 1059:  Fw::Time EventActionComponentBase ::
        -: 1060:    getTime(void)
        -: 1061:  {
    #####: 1062:    if (this->m_Time_OutputPort[0].isConnected()) {
    #####: 1063:      Fw::Time _time;
    #####: 1064:      this->m_Time_OutputPort[0].invoke(_time);
    #####: 1065:      return _time;
        -: 1066:    } else {
    #####: 1067:      return Fw::Time(TB_NONE,0,0);
        -: 1068:    }
        -: 1069:  }
        -: 1070:
        -: 1071:  // ----------------------------------------------------------------------
        -: 1072:  // Event handling functions
        -: 1073:  // ----------------------------------------------------------------------
        -: 1074:
      269: 1075:  void EventActionComponentBase ::
        -: 1076:    log_ACTIVITY_HI_EVAC_ADDED(
        -: 1077:        Fw::LogStringArg& sequence, U32 eventId
        -: 1078:    )
        -: 1079:  {
        -: 1080:
        -: 1081:
        -: 1082:    // Get the time
      538: 1083:    Fw::Time _logTime;
      269: 1084:    if (this->m_Time_OutputPort[0].isConnected()) {
      269: 1085:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1086:    }
        -: 1087:
      269: 1088:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1089:
      269: 1090:    _id = this->getIdBase() + EVENTID_EVAC_ADDED;
        -: 1091:
        -: 1092:    // Emit the event on the log port
      269: 1093:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1094:
      538: 1095:      Fw::LogBuffer _logBuff;
      269: 1096:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1097:
        -: 1098:#if FW_AMPCS_COMPATIBLE
        -: 1099:      // Serialize the number of arguments
        -: 1100:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1101:      FW_ASSERT(
        -: 1102:          _status == Fw::FW_SERIALIZE_OK,
        -: 1103:          static_cast<AssertArg>(_status)
        -: 1104:      );
        -: 1105:#endif
        -: 1106:
      269: 1107:      sequence.setMaxSerialize(40);
      269: 1108:      _status = _logBuff.serialize(sequence);
      269: 1109:      FW_ASSERT(
        -: 1110:          _status == Fw::FW_SERIALIZE_OK,
        -: 1111:          static_cast<AssertArg>(_status)
        -: 1112:      );
        -: 1113:
        -: 1114:#if FW_AMPCS_COMPATIBLE
        -: 1115:      // Serialize the argument size
        -: 1116:      _status = _logBuff.serialize(
        -: 1117:          static_cast<U8>(sizeof(eventId))
        -: 1118:      );
        -: 1119:      FW_ASSERT(
        -: 1120:          _status == Fw::FW_SERIALIZE_OK,
        -: 1121:          static_cast<AssertArg>(_status)
        -: 1122:      );
        -: 1123:#endif
        -: 1124:
      269: 1125:      _status = _logBuff.serialize(eventId);
      269: 1126:      FW_ASSERT(
        -: 1127:          _status == Fw::FW_SERIALIZE_OK,
        -: 1128:          static_cast<AssertArg>(_status)
        -: 1129:      );
        -: 1130:
        -: 1131:
      269: 1132:      this->m_eventOut_OutputPort[0].invoke(
        -: 1133:          _id,
        -: 1134:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1135:          _logBuff
        -: 1136:      );
        -: 1137:
        -: 1138:    }
        -: 1139:
        -: 1140:    // Emit the event on the text log port
        -: 1141:#if FW_ENABLE_TEXT_LOGGING
      269: 1142:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1143:
        -: 1144:#if FW_OBJECT_NAMES == 1
      269: 1145:      const char* _formatString =
        -: 1146:        "(%s) %s: Sequence %s added for event 0x%02X.";
        -: 1147:#else
        -: 1148:      const char* _formatString =
        -: 1149:        "%s: Sequence %s added for event 0x%02X.";
        -: 1150:#endif
        -: 1151:
        -: 1152:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1153:
      269: 1154:      (void) snprintf(
        -: 1155:          _textBuffer,
        -: 1156:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1157:          _formatString,
        -: 1158:#if FW_OBJECT_NAMES == 1
        -: 1159:          this->m_objName,
        -: 1160:#endif
        -: 1161:          "EVAC_ADDED "
      269: 1162:        , sequence.toChar()
        -: 1163:        , eventId
        -: 1164:      );
        -: 1165:
        -: 1166:      // Null terminate
      269: 1167:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      538: 1168:      Fw::TextLogString _logString = _textBuffer;
      269: 1169:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1170:          _id,
        -: 1171:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1172:          _logString
        -: 1173:      );
        -: 1174:
        -: 1175:    }
        -: 1176:#endif
        -: 1177:
      269: 1178:  }
        -: 1179:
        -: 1180:
       65: 1181:  void EventActionComponentBase ::
        -: 1182:    log_ACTIVITY_HI_EVAC_REMOVED(
        -: 1183:        Fw::LogStringArg& sequence, U32 eventId
        -: 1184:    )
        -: 1185:  {
        -: 1186:
        -: 1187:
        -: 1188:    // Get the time
      130: 1189:    Fw::Time _logTime;
       65: 1190:    if (this->m_Time_OutputPort[0].isConnected()) {
       65: 1191:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1192:    }
        -: 1193:
       65: 1194:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1195:
       65: 1196:    _id = this->getIdBase() + EVENTID_EVAC_REMOVED;
        -: 1197:
        -: 1198:    // Emit the event on the log port
       65: 1199:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1200:
      130: 1201:      Fw::LogBuffer _logBuff;
       65: 1202:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1203:
        -: 1204:#if FW_AMPCS_COMPATIBLE
        -: 1205:      // Serialize the number of arguments
        -: 1206:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1207:      FW_ASSERT(
        -: 1208:          _status == Fw::FW_SERIALIZE_OK,
        -: 1209:          static_cast<AssertArg>(_status)
        -: 1210:      );
        -: 1211:#endif
        -: 1212:
       65: 1213:      sequence.setMaxSerialize(40);
       65: 1214:      _status = _logBuff.serialize(sequence);
       65: 1215:      FW_ASSERT(
        -: 1216:          _status == Fw::FW_SERIALIZE_OK,
        -: 1217:          static_cast<AssertArg>(_status)
        -: 1218:      );
        -: 1219:
        -: 1220:#if FW_AMPCS_COMPATIBLE
        -: 1221:      // Serialize the argument size
        -: 1222:      _status = _logBuff.serialize(
        -: 1223:          static_cast<U8>(sizeof(eventId))
        -: 1224:      );
        -: 1225:      FW_ASSERT(
        -: 1226:          _status == Fw::FW_SERIALIZE_OK,
        -: 1227:          static_cast<AssertArg>(_status)
        -: 1228:      );
        -: 1229:#endif
        -: 1230:
       65: 1231:      _status = _logBuff.serialize(eventId);
       65: 1232:      FW_ASSERT(
        -: 1233:          _status == Fw::FW_SERIALIZE_OK,
        -: 1234:          static_cast<AssertArg>(_status)
        -: 1235:      );
        -: 1236:
        -: 1237:
       65: 1238:      this->m_eventOut_OutputPort[0].invoke(
        -: 1239:          _id,
        -: 1240:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1241:          _logBuff
        -: 1242:      );
        -: 1243:
        -: 1244:    }
        -: 1245:
        -: 1246:    // Emit the event on the text log port
        -: 1247:#if FW_ENABLE_TEXT_LOGGING
       65: 1248:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1249:
        -: 1250:#if FW_OBJECT_NAMES == 1
       65: 1251:      const char* _formatString =
        -: 1252:        "(%s) %s: Sequence %s removed for event 0x%02X.";
        -: 1253:#else
        -: 1254:      const char* _formatString =
        -: 1255:        "%s: Sequence %s removed for event 0x%02X.";
        -: 1256:#endif
        -: 1257:
        -: 1258:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1259:
       65: 1260:      (void) snprintf(
        -: 1261:          _textBuffer,
        -: 1262:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1263:          _formatString,
        -: 1264:#if FW_OBJECT_NAMES == 1
        -: 1265:          this->m_objName,
        -: 1266:#endif
        -: 1267:          "EVAC_REMOVED "
       65: 1268:        , sequence.toChar()
        -: 1269:        , eventId
        -: 1270:      );
        -: 1271:
        -: 1272:      // Null terminate
       65: 1273:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      130: 1274:      Fw::TextLogString _logString = _textBuffer;
       65: 1275:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1276:          _id,
        -: 1277:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1278:          _logString
        -: 1279:      );
        -: 1280:
        -: 1281:    }
        -: 1282:#endif
        -: 1283:
       65: 1284:  }
        -: 1285:
        -: 1286:
        8: 1287:  void EventActionComponentBase ::
        -: 1288:    log_WARNING_LO_EVAC_LIST_FULL(
        -: 1289:        U32 eventId
        -: 1290:    )
        -: 1291:  {
        -: 1292:
        -: 1293:
        -: 1294:    // Get the time
       16: 1295:    Fw::Time _logTime;
        8: 1296:    if (this->m_Time_OutputPort[0].isConnected()) {
        8: 1297:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1298:    }
        -: 1299:
        8: 1300:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1301:
        8: 1302:    _id = this->getIdBase() + EVENTID_EVAC_LIST_FULL;
        -: 1303:
        -: 1304:    // Emit the event on the log port
        8: 1305:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1306:
       16: 1307:      Fw::LogBuffer _logBuff;
        8: 1308:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1309:
        -: 1310:#if FW_AMPCS_COMPATIBLE
        -: 1311:      // Serialize the number of arguments
        -: 1312:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1313:      FW_ASSERT(
        -: 1314:          _status == Fw::FW_SERIALIZE_OK,
        -: 1315:          static_cast<AssertArg>(_status)
        -: 1316:      );
        -: 1317:#endif
        -: 1318:
        -: 1319:#if FW_AMPCS_COMPATIBLE
        -: 1320:      // Serialize the argument size
        -: 1321:      _status = _logBuff.serialize(
        -: 1322:          static_cast<U8>(sizeof(eventId))
        -: 1323:      );
        -: 1324:      FW_ASSERT(
        -: 1325:          _status == Fw::FW_SERIALIZE_OK,
        -: 1326:          static_cast<AssertArg>(_status)
        -: 1327:      );
        -: 1328:#endif
        -: 1329:
        8: 1330:      _status = _logBuff.serialize(eventId);
        8: 1331:      FW_ASSERT(
        -: 1332:          _status == Fw::FW_SERIALIZE_OK,
        -: 1333:          static_cast<AssertArg>(_status)
        -: 1334:      );
        -: 1335:
        -: 1336:
        8: 1337:      this->m_eventOut_OutputPort[0].invoke(
        -: 1338:          _id,
        -: 1339:          _logTime,Fw::LOG_WARNING_LO,
        -: 1340:          _logBuff
        -: 1341:      );
        -: 1342:
        -: 1343:    }
        -: 1344:
        -: 1345:    // Emit the event on the text log port
        -: 1346:#if FW_ENABLE_TEXT_LOGGING
        8: 1347:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1348:
        -: 1349:#if FW_OBJECT_NAMES == 1
        8: 1350:      const char* _formatString =
        -: 1351:        "(%s) %s: Unable to add sequence for event 0x%02X, list full.";
        -: 1352:#else
        -: 1353:      const char* _formatString =
        -: 1354:        "%s: Unable to add sequence for event 0x%02X, list full.";
        -: 1355:#endif
        -: 1356:
        -: 1357:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1358:
        8: 1359:      (void) snprintf(
        -: 1360:          _textBuffer,
        -: 1361:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1362:          _formatString,
        -: 1363:#if FW_OBJECT_NAMES == 1
        -: 1364:          this->m_objName,
        -: 1365:#endif
        -: 1366:          "EVAC_LIST_FULL "
        -: 1367:        , eventId
        -: 1368:      );
        -: 1369:
        -: 1370:      // Null terminate
        8: 1371:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       16: 1372:      Fw::TextLogString _logString = _textBuffer;
        8: 1373:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1374:          _id,
        -: 1375:          _logTime,Fw::TEXT_LOG_WARNING_LO,
        -: 1376:          _logString
        -: 1377:      );
        -: 1378:
        -: 1379:    }
        -: 1380:#endif
        -: 1381:
        8: 1382:  }
        -: 1383:
        -: 1384:
       52: 1385:  void EventActionComponentBase ::
        -: 1386:    log_WARNING_LO_EVAC_NOT_FOUND(
        -: 1387:        U32 eventId
        -: 1388:    )
        -: 1389:  {
        -: 1390:
        -: 1391:
        -: 1392:    // Get the time
      104: 1393:    Fw::Time _logTime;
       52: 1394:    if (this->m_Time_OutputPort[0].isConnected()) {
       52: 1395:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1396:    }
        -: 1397:
       52: 1398:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1399:
       52: 1400:    _id = this->getIdBase() + EVENTID_EVAC_NOT_FOUND;
        -: 1401:
        -: 1402:    // Emit the event on the log port
       52: 1403:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1404:
      104: 1405:      Fw::LogBuffer _logBuff;
       52: 1406:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1407:
        -: 1408:#if FW_AMPCS_COMPATIBLE
        -: 1409:      // Serialize the number of arguments
        -: 1410:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1411:      FW_ASSERT(
        -: 1412:          _status == Fw::FW_SERIALIZE_OK,
        -: 1413:          static_cast<AssertArg>(_status)
        -: 1414:      );
        -: 1415:#endif
        -: 1416:
        -: 1417:#if FW_AMPCS_COMPATIBLE
        -: 1418:      // Serialize the argument size
        -: 1419:      _status = _logBuff.serialize(
        -: 1420:          static_cast<U8>(sizeof(eventId))
        -: 1421:      );
        -: 1422:      FW_ASSERT(
        -: 1423:          _status == Fw::FW_SERIALIZE_OK,
        -: 1424:          static_cast<AssertArg>(_status)
        -: 1425:      );
        -: 1426:#endif
        -: 1427:
       52: 1428:      _status = _logBuff.serialize(eventId);
       52: 1429:      FW_ASSERT(
        -: 1430:          _status == Fw::FW_SERIALIZE_OK,
        -: 1431:          static_cast<AssertArg>(_status)
        -: 1432:      );
        -: 1433:
        -: 1434:
       52: 1435:      this->m_eventOut_OutputPort[0].invoke(
        -: 1436:          _id,
        -: 1437:          _logTime,Fw::LOG_WARNING_LO,
        -: 1438:          _logBuff
        -: 1439:      );
        -: 1440:
        -: 1441:    }
        -: 1442:
        -: 1443:    // Emit the event on the text log port
        -: 1444:#if FW_ENABLE_TEXT_LOGGING
       52: 1445:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1446:
        -: 1447:#if FW_OBJECT_NAMES == 1
       52: 1448:      const char* _formatString =
        -: 1449:        "(%s) %s: Unable to remove sequence for event 0x%02X, not found.";
        -: 1450:#else
        -: 1451:      const char* _formatString =
        -: 1452:        "%s: Unable to remove sequence for event 0x%02X, not found.";
        -: 1453:#endif
        -: 1454:
        -: 1455:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1456:
       52: 1457:      (void) snprintf(
        -: 1458:          _textBuffer,
        -: 1459:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1460:          _formatString,
        -: 1461:#if FW_OBJECT_NAMES == 1
        -: 1462:          this->m_objName,
        -: 1463:#endif
        -: 1464:          "EVAC_NOT_FOUND "
        -: 1465:        , eventId
        -: 1466:      );
        -: 1467:
        -: 1468:      // Null terminate
       52: 1469:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
      104: 1470:      Fw::TextLogString _logString = _textBuffer;
       52: 1471:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1472:          _id,
        -: 1473:          _logTime,Fw::TEXT_LOG_WARNING_LO,
        -: 1474:          _logString
        -: 1475:      );
        -: 1476:
        -: 1477:    }
        -: 1478:#endif
        -: 1479:
       52: 1480:  }
        -: 1481:
        -: 1482:
       10: 1483:  void EventActionComponentBase ::
        -: 1484:    log_WARNING_HI_EVAC_ALREADY_REGISTERED(
        -: 1485:        U32 eventId, Fw::LogStringArg& sequence
        -: 1486:    )
        -: 1487:  {
        -: 1488:
        -: 1489:
        -: 1490:    // Get the time
       20: 1491:    Fw::Time _logTime;
       10: 1492:    if (this->m_Time_OutputPort[0].isConnected()) {
       10: 1493:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1494:    }
        -: 1495:
       10: 1496:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1497:
       10: 1498:    _id = this->getIdBase() + EVENTID_EVAC_ALREADY_REGISTERED;
        -: 1499:
        -: 1500:    // Emit the event on the log port
       10: 1501:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1502:
       20: 1503:      Fw::LogBuffer _logBuff;
       10: 1504:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1505:
        -: 1506:#if FW_AMPCS_COMPATIBLE
        -: 1507:      // Serialize the number of arguments
        -: 1508:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1509:      FW_ASSERT(
        -: 1510:          _status == Fw::FW_SERIALIZE_OK,
        -: 1511:          static_cast<AssertArg>(_status)
        -: 1512:      );
        -: 1513:#endif
        -: 1514:
        -: 1515:#if FW_AMPCS_COMPATIBLE
        -: 1516:      // Serialize the argument size
        -: 1517:      _status = _logBuff.serialize(
        -: 1518:          static_cast<U8>(sizeof(eventId))
        -: 1519:      );
        -: 1520:      FW_ASSERT(
        -: 1521:          _status == Fw::FW_SERIALIZE_OK,
        -: 1522:          static_cast<AssertArg>(_status)
        -: 1523:      );
        -: 1524:#endif
        -: 1525:
       10: 1526:      _status = _logBuff.serialize(eventId);
       10: 1527:      FW_ASSERT(
        -: 1528:          _status == Fw::FW_SERIALIZE_OK,
        -: 1529:          static_cast<AssertArg>(_status)
        -: 1530:      );
        -: 1531:
       10: 1532:      sequence.setMaxSerialize(40);
       10: 1533:      _status = _logBuff.serialize(sequence);
       10: 1534:      FW_ASSERT(
        -: 1535:          _status == Fw::FW_SERIALIZE_OK,
        -: 1536:          static_cast<AssertArg>(_status)
        -: 1537:      );
        -: 1538:
        -: 1539:
       10: 1540:      this->m_eventOut_OutputPort[0].invoke(
        -: 1541:          _id,
        -: 1542:          _logTime,Fw::LOG_WARNING_HI,
        -: 1543:          _logBuff
        -: 1544:      );
        -: 1545:
        -: 1546:    }
        -: 1547:
        -: 1548:    // Emit the event on the text log port
        -: 1549:#if FW_ENABLE_TEXT_LOGGING
       10: 1550:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1551:
        -: 1552:#if FW_OBJECT_NAMES == 1
       10: 1553:      const char* _formatString =
        -: 1554:        "(%s) %s: Unable to add sequence - Event 0x%02X already registered for sequence %s";
        -: 1555:#else
        -: 1556:      const char* _formatString =
        -: 1557:        "%s: Unable to add sequence - Event 0x%02X already registered for sequence %s";
        -: 1558:#endif
        -: 1559:
        -: 1560:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1561:
       10: 1562:      (void) snprintf(
        -: 1563:          _textBuffer,
        -: 1564:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1565:          _formatString,
        -: 1566:#if FW_OBJECT_NAMES == 1
        -: 1567:          this->m_objName,
        -: 1568:#endif
        -: 1569:          "EVAC_ALREADY_REGISTERED "
        -: 1570:        , eventId
       10: 1571:        , sequence.toChar()
        -: 1572:      );
        -: 1573:
        -: 1574:      // Null terminate
       10: 1575:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       20: 1576:      Fw::TextLogString _logString = _textBuffer;
       10: 1577:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1578:          _id,
        -: 1579:          _logTime,Fw::TEXT_LOG_WARNING_HI,
        -: 1580:          _logString
        -: 1581:      );
        -: 1582:
        -: 1583:    }
        -: 1584:#endif
        -: 1585:
       10: 1586:  }
        -: 1587:
        -: 1588:
       47: 1589:  void EventActionComponentBase ::
        -: 1590:    log_ACTIVITY_HI_EVAC_DUMP(
        -: 1591:        Fw::LogStringArg& sequence, U32 eventId
        -: 1592:    )
        -: 1593:  {
        -: 1594:
        -: 1595:
        -: 1596:    // Get the time
       94: 1597:    Fw::Time _logTime;
       47: 1598:    if (this->m_Time_OutputPort[0].isConnected()) {
       47: 1599:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1600:    }
        -: 1601:
       47: 1602:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1603:
       47: 1604:    _id = this->getIdBase() + EVENTID_EVAC_DUMP;
        -: 1605:
        -: 1606:    // Emit the event on the log port
       47: 1607:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1608:
       94: 1609:      Fw::LogBuffer _logBuff;
       47: 1610:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1611:
        -: 1612:#if FW_AMPCS_COMPATIBLE
        -: 1613:      // Serialize the number of arguments
        -: 1614:      _status = _logBuff.serialize(static_cast<U8>(2));
        -: 1615:      FW_ASSERT(
        -: 1616:          _status == Fw::FW_SERIALIZE_OK,
        -: 1617:          static_cast<AssertArg>(_status)
        -: 1618:      );
        -: 1619:#endif
        -: 1620:
       47: 1621:      sequence.setMaxSerialize(40);
       47: 1622:      _status = _logBuff.serialize(sequence);
       47: 1623:      FW_ASSERT(
        -: 1624:          _status == Fw::FW_SERIALIZE_OK,
        -: 1625:          static_cast<AssertArg>(_status)
        -: 1626:      );
        -: 1627:
        -: 1628:#if FW_AMPCS_COMPATIBLE
        -: 1629:      // Serialize the argument size
        -: 1630:      _status = _logBuff.serialize(
        -: 1631:          static_cast<U8>(sizeof(eventId))
        -: 1632:      );
        -: 1633:      FW_ASSERT(
        -: 1634:          _status == Fw::FW_SERIALIZE_OK,
        -: 1635:          static_cast<AssertArg>(_status)
        -: 1636:      );
        -: 1637:#endif
        -: 1638:
       47: 1639:      _status = _logBuff.serialize(eventId);
       47: 1640:      FW_ASSERT(
        -: 1641:          _status == Fw::FW_SERIALIZE_OK,
        -: 1642:          static_cast<AssertArg>(_status)
        -: 1643:      );
        -: 1644:
        -: 1645:
       47: 1646:      this->m_eventOut_OutputPort[0].invoke(
        -: 1647:          _id,
        -: 1648:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1649:          _logBuff
        -: 1650:      );
        -: 1651:
        -: 1652:    }
        -: 1653:
        -: 1654:    // Emit the event on the text log port
        -: 1655:#if FW_ENABLE_TEXT_LOGGING
       47: 1656:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1657:
        -: 1658:#if FW_OBJECT_NAMES == 1
       47: 1659:      const char* _formatString =
        -: 1660:        "(%s) %s: Sequence %s registered for event 0x%02X";
        -: 1661:#else
        -: 1662:      const char* _formatString =
        -: 1663:        "%s: Sequence %s registered for event 0x%02X";
        -: 1664:#endif
        -: 1665:
        -: 1666:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1667:
       47: 1668:      (void) snprintf(
        -: 1669:          _textBuffer,
        -: 1670:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1671:          _formatString,
        -: 1672:#if FW_OBJECT_NAMES == 1
        -: 1673:          this->m_objName,
        -: 1674:#endif
        -: 1675:          "EVAC_DUMP "
       47: 1676:        , sequence.toChar()
        -: 1677:        , eventId
        -: 1678:      );
        -: 1679:
        -: 1680:      // Null terminate
       47: 1681:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
       94: 1682:      Fw::TextLogString _logString = _textBuffer;
       47: 1683:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1684:          _id,
        -: 1685:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1686:          _logString
        -: 1687:      );
        -: 1688:
        -: 1689:    }
        -: 1690:#endif
        -: 1691:
       47: 1692:  }
        -: 1693:
        -: 1694:
    #####: 1695:  void EventActionComponentBase ::
        -: 1696:    log_ACTIVITY_HI_EVAC_EVENT(
        -: 1697:        Fw::LogStringArg& message
        -: 1698:    )
        -: 1699:  {
        -: 1700:
        -: 1701:
        -: 1702:    // Get the time
    #####: 1703:    Fw::Time _logTime;
    #####: 1704:    if (this->m_Time_OutputPort[0].isConnected()) {
    #####: 1705:       this->m_Time_OutputPort[0].invoke( _logTime);
        -: 1706:    }
        -: 1707:
    #####: 1708:    FwEventIdType _id = static_cast<FwEventIdType>(0);
        -: 1709:
    #####: 1710:    _id = this->getIdBase() + EVENTID_EVAC_EVENT;
        -: 1711:
        -: 1712:    // Emit the event on the log port
    #####: 1713:    if (this->m_eventOut_OutputPort[0].isConnected()) {
        -: 1714:
    #####: 1715:      Fw::LogBuffer _logBuff;
    #####: 1716:      Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1717:
        -: 1718:#if FW_AMPCS_COMPATIBLE
        -: 1719:      // Serialize the number of arguments
        -: 1720:      _status = _logBuff.serialize(static_cast<U8>(1));
        -: 1721:      FW_ASSERT(
        -: 1722:          _status == Fw::FW_SERIALIZE_OK,
        -: 1723:          static_cast<AssertArg>(_status)
        -: 1724:      );
        -: 1725:#endif
        -: 1726:
    #####: 1727:      message.setMaxSerialize(40);
    #####: 1728:      _status = _logBuff.serialize(message);
    #####: 1729:      FW_ASSERT(
        -: 1730:          _status == Fw::FW_SERIALIZE_OK,
        -: 1731:          static_cast<AssertArg>(_status)
        -: 1732:      );
        -: 1733:
        -: 1734:
    #####: 1735:      this->m_eventOut_OutputPort[0].invoke(
        -: 1736:          _id,
        -: 1737:          _logTime,Fw::LOG_ACTIVITY_HI,
        -: 1738:          _logBuff
        -: 1739:      );
        -: 1740:
        -: 1741:    }
        -: 1742:
        -: 1743:    // Emit the event on the text log port
        -: 1744:#if FW_ENABLE_TEXT_LOGGING
    #####: 1745:    if (this->m_txtEventOut_OutputPort[0].isConnected()) {
        -: 1746:
        -: 1747:#if FW_OBJECT_NAMES == 1
    #####: 1748:      const char* _formatString =
        -: 1749:        "(%s) %s: EventAction - %s";
        -: 1750:#else
        -: 1751:      const char* _formatString =
        -: 1752:        "%s: EventAction - %s";
        -: 1753:#endif
        -: 1754:
        -: 1755:      char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];
        -: 1756:
    #####: 1757:      (void) snprintf(
        -: 1758:          _textBuffer,
        -: 1759:          FW_LOG_TEXT_BUFFER_SIZE,
        -: 1760:          _formatString,
        -: 1761:#if FW_OBJECT_NAMES == 1
        -: 1762:          this->m_objName,
        -: 1763:#endif
        -: 1764:          "EVAC_EVENT "
    #####: 1765:        , message.toChar()
        -: 1766:      );
        -: 1767:
        -: 1768:      // Null terminate
    #####: 1769:      _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    #####: 1770:      Fw::TextLogString _logString = _textBuffer;
    #####: 1771:      this->m_txtEventOut_OutputPort[0].invoke(
        -: 1772:          _id,
        -: 1773:          _logTime,Fw::TEXT_LOG_ACTIVITY_HI,
        -: 1774:          _logString
        -: 1775:      );
        -: 1776:
        -: 1777:    }
        -: 1778:#endif
        -: 1779:
    #####: 1780:  }
        -: 1781:
        -: 1782:
        -: 1783:  // ----------------------------------------------------------------------
        -: 1784:  // Calls for invocations received on typed input ports
        -: 1785:  // ----------------------------------------------------------------------
        -: 1786:
    #####: 1787:  void EventActionComponentBase ::
        -: 1788:    m_p_seqResp_in(
        -: 1789:        Fw::PassiveComponentBase* callComp,
        -: 1790:        NATIVE_INT_TYPE portNum,
        -: 1791:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 1792:    )
        -: 1793:  {
    #####: 1794:    FW_ASSERT(callComp);
    #####: 1795:    EventActionComponentBase* compPtr =
        -: 1796:      (EventActionComponentBase*) callComp;
    #####: 1797:    compPtr->seqResp_handlerBase(portNum, opCode, cmdSeq, response);
    #####: 1798:  }
        -: 1799:
    #####: 1800:  void EventActionComponentBase ::
        -: 1801:    m_p_logRecv_in(
        -: 1802:        Fw::PassiveComponentBase* callComp,
        -: 1803:        NATIVE_INT_TYPE portNum,
        -: 1804:        FwEventIdType id, Fw::Time &timeTag, Fw::LogSeverity severity, Fw::LogBuffer &args
        -: 1805:    )
        -: 1806:  {
    #####: 1807:    FW_ASSERT(callComp);
    #####: 1808:    EventActionComponentBase* compPtr =
        -: 1809:      (EventActionComponentBase*) callComp;
    #####: 1810:    compPtr->logRecv_handlerBase(portNum, id, timeTag, severity, args);
    #####: 1811:  }
        -: 1812:
        -: 1813:  // ----------------------------------------------------------------------
        -: 1814:  // Port handler base-class functions for typed input ports
        -: 1815:  // ----------------------------------------------------------------------
        -: 1816:
    #####: 1817:  void EventActionComponentBase ::
        -: 1818:    seqResp_handlerBase(
        -: 1819:        NATIVE_INT_TYPE portNum,
        -: 1820:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 1821:    )
        -: 1822:  {
        -: 1823:
        -: 1824:    // Make sure port number is valid
    #####: 1825:    FW_ASSERT(portNum < this->getNum_seqResp_InputPorts(),static_cast<AssertArg>(portNum));
        -: 1826:
        -: 1827:    // Call pre-message hook
    #####: 1828:    seqResp_preMsgHook(
        -: 1829:        portNum,
        -: 1830:        opCode, cmdSeq, response
    #####: 1831:    );
        -: 1832:
    #####: 1833:    ComponentIpcSerializableBuffer msg;
    #####: 1834:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1835:
    #####: 1836:    _status = msg.serialize(
        -: 1837:        static_cast<NATIVE_INT_TYPE>(SEQRESP_CMDRESPONSE)
        -: 1838:    );
    #####: 1839:    FW_ASSERT (
        -: 1840:        _status == Fw::FW_SERIALIZE_OK,
        -: 1841:        static_cast<AssertArg>(_status)
        -: 1842:    );
        -: 1843:
    #####: 1844:    _status = msg.serialize(portNum);
    #####: 1845:    FW_ASSERT (
        -: 1846:        _status == Fw::FW_SERIALIZE_OK,
        -: 1847:        static_cast<AssertArg>(_status)
        -: 1848:    );
        -: 1849:
        -: 1850:    // Serialize argument opCode
    #####: 1851:    _status = msg.serialize(opCode);
    #####: 1852:    FW_ASSERT(
        -: 1853:        _status == Fw::FW_SERIALIZE_OK,
        -: 1854:        static_cast<AssertArg>(_status)
        -: 1855:    );
        -: 1856:
        -: 1857:    // Serialize argument cmdSeq
    #####: 1858:    _status = msg.serialize(cmdSeq);
    #####: 1859:    FW_ASSERT(
        -: 1860:        _status == Fw::FW_SERIALIZE_OK,
        -: 1861:        static_cast<AssertArg>(_status)
        -: 1862:    );
        -: 1863:
        -: 1864:    // Serialize argument response
    #####: 1865:    _status = msg.serialize(static_cast<FwEnumStoreType>(response));
    #####: 1866:    FW_ASSERT(
        -: 1867:        _status == Fw::FW_SERIALIZE_OK,
        -: 1868:        static_cast<AssertArg>(_status)
        -: 1869:    );
        -: 1870:
        -: 1871:
        -: 1872:    // send message
    #####: 1873:    Os::Queue::QueueBlocking _block =
        -: 1874:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1875:    Os::Queue::QueueStatus qStatus =
    #####: 1876:      this->m_queue.send(msg, 0,_block);
    #####: 1877:    FW_ASSERT(
        -: 1878:        qStatus == Os::Queue::QUEUE_OK,
        -: 1879:        static_cast<AssertArg>(qStatus)
        -: 1880:    );
        -: 1881:
    #####: 1882:  }
        -: 1883:
    #####: 1884:  void EventActionComponentBase ::
        -: 1885:    logRecv_handlerBase(
        -: 1886:        NATIVE_INT_TYPE portNum,
        -: 1887:        FwEventIdType id, Fw::Time &timeTag, Fw::LogSeverity severity, Fw::LogBuffer &args
        -: 1888:    )
        -: 1889:  {
        -: 1890:
        -: 1891:    // Make sure port number is valid
    #####: 1892:    FW_ASSERT(portNum < this->getNum_logRecv_InputPorts(),static_cast<AssertArg>(portNum));
        -: 1893:
        -: 1894:    // Call pre-message hook
    #####: 1895:    logRecv_preMsgHook(
        -: 1896:        portNum,
        -: 1897:        id, timeTag, severity, args
    #####: 1898:    );
        -: 1899:
    #####: 1900:    ComponentIpcSerializableBuffer msg;
    #####: 1901:    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
        -: 1902:
    #####: 1903:    _status = msg.serialize(
        -: 1904:        static_cast<NATIVE_INT_TYPE>(LOGRECV_LOG)
        -: 1905:    );
    #####: 1906:    FW_ASSERT (
        -: 1907:        _status == Fw::FW_SERIALIZE_OK,
        -: 1908:        static_cast<AssertArg>(_status)
        -: 1909:    );
        -: 1910:
    #####: 1911:    _status = msg.serialize(portNum);
    #####: 1912:    FW_ASSERT (
        -: 1913:        _status == Fw::FW_SERIALIZE_OK,
        -: 1914:        static_cast<AssertArg>(_status)
        -: 1915:    );
        -: 1916:
        -: 1917:    // Serialize argument id
    #####: 1918:    _status = msg.serialize(id);
    #####: 1919:    FW_ASSERT(
        -: 1920:        _status == Fw::FW_SERIALIZE_OK,
        -: 1921:        static_cast<AssertArg>(_status)
        -: 1922:    );
        -: 1923:
        -: 1924:    // Serialize argument timeTag
    #####: 1925:    _status = msg.serialize(timeTag);
    #####: 1926:    FW_ASSERT(
        -: 1927:        _status == Fw::FW_SERIALIZE_OK,
        -: 1928:        static_cast<AssertArg>(_status)
        -: 1929:    );
        -: 1930:
        -: 1931:    // Serialize argument severity
    #####: 1932:    _status = msg.serialize(static_cast<FwEnumStoreType>(severity));
    #####: 1933:    FW_ASSERT(
        -: 1934:        _status == Fw::FW_SERIALIZE_OK,
        -: 1935:        static_cast<AssertArg>(_status)
        -: 1936:    );
        -: 1937:
        -: 1938:    // Serialize argument args
    #####: 1939:    _status = msg.serialize(args);
    #####: 1940:    FW_ASSERT(
        -: 1941:        _status == Fw::FW_SERIALIZE_OK,
        -: 1942:        static_cast<AssertArg>(_status)
        -: 1943:    );
        -: 1944:
        -: 1945:
        -: 1946:    // send message
    #####: 1947:    Os::Queue::QueueBlocking _block =
        -: 1948:      Os::Queue::QUEUE_NONBLOCKING;
        -: 1949:    Os::Queue::QueueStatus qStatus =
    #####: 1950:      this->m_queue.send(msg, 0,_block);
    #####: 1951:    FW_ASSERT(
        -: 1952:        qStatus == Os::Queue::QUEUE_OK,
        -: 1953:        static_cast<AssertArg>(qStatus)
        -: 1954:    );
        -: 1955:
    #####: 1956:  }
        -: 1957:
        -: 1958:  // ----------------------------------------------------------------------
        -: 1959:  // Pre-message hooks for async input ports
        -: 1960:  // ----------------------------------------------------------------------
        -: 1961:
    #####: 1962:  void EventActionComponentBase ::
        -: 1963:    seqResp_preMsgHook(
        -: 1964:        NATIVE_INT_TYPE portNum,
        -: 1965:        FwOpcodeType opCode, U32 cmdSeq, Fw::CommandResponse response
        -: 1966:    )
        -: 1967:  {
        -: 1968:    // Default: no-op
    #####: 1969:  }
        -: 1970:
    #####: 1971:  void EventActionComponentBase ::
        -: 1972:    logRecv_preMsgHook(
        -: 1973:        NATIVE_INT_TYPE portNum,
        -: 1974:        FwEventIdType id, Fw::Time &timeTag, Fw::LogSeverity severity, Fw::LogBuffer &args
        -: 1975:    )
        -: 1976:  {
        -: 1977:    // Default: no-op
    #####: 1978:  }
        -: 1979:
        -: 1980:  // ----------------------------------------------------------------------
        -: 1981:  // Message dispatch method for active and queued components. Called
        -: 1982:  // by active component thread or implementation code for queued components
        -: 1983:  // ----------------------------------------------------------------------
        -: 1984:
      461: 1985:  Fw::QueuedComponentBase::MsgDispatchStatus EventActionComponentBase ::
        -: 1986:    doDispatch(void)
        -: 1987:  {
      922: 1988:    ComponentIpcSerializableBuffer msg;
        -: 1989:    NATIVE_INT_TYPE priority;
        -: 1990:
      461: 1991:    Os::Queue::QueueStatus msgStatus = this->m_queue.receive(msg,priority,Os::Queue::QUEUE_BLOCKING);
      461: 1992:    FW_ASSERT(
        -: 1993:        msgStatus == Os::Queue::QUEUE_OK,
        -: 1994:        static_cast<AssertArg>(msgStatus)
        -: 1995:    );
        -: 1996:
        -: 1997:    // Reset to beginning of buffer
      461: 1998:    msg.resetDeser();
        -: 1999:
        -: 2000:    NATIVE_INT_TYPE desMsg;
      461: 2001:    Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
      461: 2002:    FW_ASSERT(
        -: 2003:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2004:        static_cast<AssertArg>(deserStatus)
        -: 2005:    );
        -: 2006:
      461: 2007:    MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);
        -: 2008:
      461: 2009:    if (msgType == EVENTACTION_COMPONENT_EXIT) {
    #####: 2010:      return MSG_DISPATCH_EXIT;
        -: 2011:    }
        -: 2012:
        -: 2013:    NATIVE_INT_TYPE portNum;
      461: 2014:    deserStatus = msg.deserialize(portNum);
      461: 2015:    FW_ASSERT(
        -: 2016:        deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2017:        static_cast<AssertArg>(deserStatus)
        -: 2018:    );
        -: 2019:
      461: 2020:    switch (msgType) {
        -: 2021:
        -: 2022:      // Handle async input port seqResp
    #####: 2023:      case SEQRESP_CMDRESPONSE: {
        -: 2024:
        -: 2025:        // Deserialize argument opCode
        -: 2026:        FwOpcodeType opCode;
    #####: 2027:        deserStatus = msg.deserialize(opCode);
    #####: 2028:        FW_ASSERT(
        -: 2029:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2030:            static_cast<AssertArg>(deserStatus)
        -: 2031:        );
        -: 2032:
        -: 2033:        // Deserialize argument cmdSeq
        -: 2034:        U32 cmdSeq;
    #####: 2035:        deserStatus = msg.deserialize(cmdSeq);
    #####: 2036:        FW_ASSERT(
        -: 2037:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2038:            static_cast<AssertArg>(deserStatus)
        -: 2039:        );
        -: 2040:
        -: 2041:        // Deserialize argument response
        -: 2042:        Fw::CommandResponse response;
        -: 2043:        FwEnumStoreType responseInt;
    #####: 2044:        deserStatus = msg.deserialize(responseInt);
    #####: 2045:        response = (Fw::CommandResponse) responseInt;
    #####: 2046:        FW_ASSERT(
        -: 2047:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2048:            static_cast<AssertArg>(deserStatus)
        -: 2049:        );
        -: 2050:
        -: 2051:        // Call handler function
    #####: 2052:        this->seqResp_handler(
        -: 2053:            portNum,
        -: 2054:            opCode, cmdSeq, response
    #####: 2055:        );
        -: 2056:
    #####: 2057:        break;
        -: 2058:
        -: 2059:      }
        -: 2060:
        -: 2061:      // Handle async input port logRecv
    #####: 2062:      case LOGRECV_LOG: {
        -: 2063:
        -: 2064:        // Deserialize argument id
        -: 2065:        FwEventIdType id;
    #####: 2066:        deserStatus = msg.deserialize(id);
    #####: 2067:        FW_ASSERT(
        -: 2068:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2069:            static_cast<AssertArg>(deserStatus)
        -: 2070:        );
        -: 2071:
        -: 2072:        // Deserialize argument timeTag
    #####: 2073:        Fw::Time timeTag;
    #####: 2074:        deserStatus = msg.deserialize(timeTag);
    #####: 2075:        FW_ASSERT(
        -: 2076:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2077:            static_cast<AssertArg>(deserStatus)
        -: 2078:        );
        -: 2079:
        -: 2080:        // Deserialize argument severity
        -: 2081:        Fw::LogSeverity severity;
        -: 2082:        FwEnumStoreType severityInt;
    #####: 2083:        deserStatus = msg.deserialize(severityInt);
    #####: 2084:        severity = (Fw::LogSeverity) severityInt;
    #####: 2085:        FW_ASSERT(
        -: 2086:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2087:            static_cast<AssertArg>(deserStatus)
        -: 2088:        );
        -: 2089:
        -: 2090:        // Deserialize argument args
    #####: 2091:        Fw::LogBuffer args;
    #####: 2092:        deserStatus = msg.deserialize(args);
    #####: 2093:        FW_ASSERT(
        -: 2094:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2095:            static_cast<AssertArg>(deserStatus)
        -: 2096:        );
        -: 2097:
        -: 2098:        // Call handler function
    #####: 2099:        this->logRecv_handler(
        -: 2100:            portNum,
        -: 2101:            id, timeTag, severity, args
    #####: 2102:        );
        -: 2103:
    #####: 2104:        break;
        -: 2105:
        -: 2106:      }
        -: 2107:
        -: 2108:      // Handle command EVAC_ADD
      287: 2109:      case CMD_EVAC_ADD: {
        -: 2110:        // Deserialize opcode
        -: 2111:        FwOpcodeType opCode;
      287: 2112:        deserStatus = msg.deserialize(opCode);
      287: 2113:        FW_ASSERT (
        -: 2114:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2115:            static_cast<AssertArg>(deserStatus)
        -: 2116:        );
        -: 2117:
        -: 2118:        // Deserialize command sequence
        -: 2119:        U32 cmdSeq;
      287: 2120:        deserStatus = msg.deserialize(cmdSeq);
      287: 2121:        FW_ASSERT (
        -: 2122:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2123:            static_cast<AssertArg>(deserStatus)
        -: 2124:        );
        -: 2125:
        -: 2126:        // Deserialize command argument buffer
      574: 2127:        Fw::CmdArgBuffer args;
      287: 2128:        deserStatus = msg.deserialize(args);
      287: 2129:        FW_ASSERT (
        -: 2130:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2131:            static_cast<AssertArg>(deserStatus)
        -: 2132:        );
        -: 2133:
        -: 2134:        // Reset buffer
      287: 2135:        args.resetDeser();
        -: 2136:
        -: 2137:        // Deserialize argument id
        -: 2138:        U32 id;
      287: 2139:        deserStatus = args.deserialize(id);
      287: 2140:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2141:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2142:            this->cmdResponse_out(
        -: 2143:                opCode,
        -: 2144:                cmdSeq,
        -: 2145:                Fw::COMMAND_FORMAT_ERROR
        -: 2146:            );
        -: 2147:          }
        -: 2148:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2149:          break;
        -: 2150:        }
        -: 2151:
        -: 2152:        // Deserialize argument sequence
      574: 2153:        Fw::CmdStringArg sequence;
      287: 2154:        deserStatus = args.deserialize(sequence);
      287: 2155:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2156:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2157:            this->cmdResponse_out(
        -: 2158:                opCode,
        -: 2159:                cmdSeq,
        -: 2160:                Fw::COMMAND_FORMAT_ERROR
        -: 2161:            );
        -: 2162:          }
        -: 2163:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2164:          break;
        -: 2165:        }
        -: 2166:
        -: 2167:        // Make sure there was no data left over.
        -: 2168:        // That means the argument buffer size was incorrect.
        -: 2169:#if FW_CMD_CHECK_RESIDUAL
      287: 2170:        if (args.getBuffLeft() != 0) {
    #####: 2171:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2172:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2173:          }
        -: 2174:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2175:          break;
        -: 2176:        }
        -: 2177:#endif
        -: 2178:        // Call handler function
      287: 2179:        this->EVAC_ADD_cmdHandler(
        -: 2180:            opCode,
        -: 2181:            cmdSeq,
        -: 2182:            id, sequence
      287: 2183:        );
        -: 2184:
      287: 2185:        break;
        -: 2186:
        -: 2187:      }
        -: 2188:
        -: 2189:      // Handle command EVAC_REMOVE
      117: 2190:      case CMD_EVAC_REMOVE: {
        -: 2191:        // Deserialize opcode
        -: 2192:        FwOpcodeType opCode;
      117: 2193:        deserStatus = msg.deserialize(opCode);
      117: 2194:        FW_ASSERT (
        -: 2195:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2196:            static_cast<AssertArg>(deserStatus)
        -: 2197:        );
        -: 2198:
        -: 2199:        // Deserialize command sequence
        -: 2200:        U32 cmdSeq;
      117: 2201:        deserStatus = msg.deserialize(cmdSeq);
      117: 2202:        FW_ASSERT (
        -: 2203:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2204:            static_cast<AssertArg>(deserStatus)
        -: 2205:        );
        -: 2206:
        -: 2207:        // Deserialize command argument buffer
      234: 2208:        Fw::CmdArgBuffer args;
      117: 2209:        deserStatus = msg.deserialize(args);
      117: 2210:        FW_ASSERT (
        -: 2211:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2212:            static_cast<AssertArg>(deserStatus)
        -: 2213:        );
        -: 2214:
        -: 2215:        // Reset buffer
      117: 2216:        args.resetDeser();
        -: 2217:
        -: 2218:        // Deserialize argument id
        -: 2219:        U32 id;
      117: 2220:        deserStatus = args.deserialize(id);
      117: 2221:        if (deserStatus != Fw::FW_SERIALIZE_OK) {
    #####: 2222:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2223:            this->cmdResponse_out(
        -: 2224:                opCode,
        -: 2225:                cmdSeq,
        -: 2226:                Fw::COMMAND_FORMAT_ERROR
        -: 2227:            );
        -: 2228:          }
        -: 2229:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2230:          break;
        -: 2231:        }
        -: 2232:
        -: 2233:        // Make sure there was no data left over.
        -: 2234:        // That means the argument buffer size was incorrect.
        -: 2235:#if FW_CMD_CHECK_RESIDUAL
      117: 2236:        if (args.getBuffLeft() != 0) {
    #####: 2237:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2238:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2239:          }
        -: 2240:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2241:          break;
        -: 2242:        }
        -: 2243:#endif
        -: 2244:        // Call handler function
      117: 2245:        this->EVAC_REMOVE_cmdHandler(
        -: 2246:            opCode,
        -: 2247:            cmdSeq,
        -: 2248:            id
      117: 2249:        );
        -: 2250:
      117: 2251:        break;
        -: 2252:
        -: 2253:      }
        -: 2254:
        -: 2255:      // Handle command EVAC_DUMP
       57: 2256:      case CMD_EVAC_DUMP: {
        -: 2257:        // Deserialize opcode
        -: 2258:        FwOpcodeType opCode;
       57: 2259:        deserStatus = msg.deserialize(opCode);
       57: 2260:        FW_ASSERT (
        -: 2261:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2262:            static_cast<AssertArg>(deserStatus)
        -: 2263:        );
        -: 2264:
        -: 2265:        // Deserialize command sequence
        -: 2266:        U32 cmdSeq;
       57: 2267:        deserStatus = msg.deserialize(cmdSeq);
       57: 2268:        FW_ASSERT (
        -: 2269:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2270:            static_cast<AssertArg>(deserStatus)
        -: 2271:        );
        -: 2272:
        -: 2273:        // Deserialize command argument buffer
      114: 2274:        Fw::CmdArgBuffer args;
       57: 2275:        deserStatus = msg.deserialize(args);
       57: 2276:        FW_ASSERT (
        -: 2277:            deserStatus == Fw::FW_SERIALIZE_OK,
        -: 2278:            static_cast<AssertArg>(deserStatus)
        -: 2279:        );
        -: 2280:
        -: 2281:        // Reset buffer
       57: 2282:        args.resetDeser();
        -: 2283:
        -: 2284:        // Make sure there was no data left over.
        -: 2285:        // That means the argument buffer size was incorrect.
        -: 2286:#if FW_CMD_CHECK_RESIDUAL
       57: 2287:        if (args.getBuffLeft() != 0) {
    #####: 2288:          if (this->m_cmdResponseOut_OutputPort[0].isConnected()) {
    #####: 2289:            this->cmdResponse_out(opCode,cmdSeq,Fw::COMMAND_FORMAT_ERROR);
        -: 2290:          }
        -: 2291:          // Don't crash the task if bad arguments were passed from the ground
    #####: 2292:          break;
        -: 2293:        }
        -: 2294:#endif
        -: 2295:        // Call handler function
       57: 2296:        this->EVAC_DUMP_cmdHandler(opCode, cmdSeq);
        -: 2297:
       57: 2298:        break;
        -: 2299:
        -: 2300:      }
        -: 2301:
    #####: 2302:      default:
    #####: 2303:        return MSG_DISPATCH_ERROR;
        -: 2304:
        -: 2305:    }
        -: 2306:
      461: 2307:    return MSG_DISPATCH_OK;
        -: 2308:
        -: 2309:  }
        -: 2310:
      255: 2311:} // end namespace App
